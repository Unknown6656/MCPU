<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>#define SILENT
#define UNSAFE

// maybe (hopefully) this code file will be obsolete in C# 8
// Autogenerated  <#=$"{DateTime.Now:yyyy-MM-dd HH:mm:ss:ffffff}   {TimeZoneInfo.Local.DisplayName}" #>

using System;

namespace MCPU.Compiler
{
#if UNSAFE
	/// <summary>
    /// An interface for discriminated type-unsafe unions
    /// </summary>
    public interface IUnsafeUnion
    {
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
        _ As<_>();
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
        bool Is<_>();
		/// <summary>
        /// The union's type-unsafe item
		/// </summary>
        object UnsafeItem { get; }
    }
#endif
<#
char BigC(int i) => (char)('A' + i);
char SmallC(int i) => (char)('a' + i);

for (int i = 2; i <= 26; i++)
{
	string type_str = string.Join(", ", from c in Enumerable.Range(0, i) select BigC(c));
	string func_str = string.Join(", ", from j in Enumerable.Range(0, i) select $"Func<{BigC(j)}, _> {SmallC(j)}");
	string act_str = string.Join(", ", from j in Enumerable.Range(0, i) select $"Action<{BigC(j)}> {SmallC(j)}");
#>

#if UNSAFE
	/// <summary>
    /// A generic type-unsafe discriminated union with <#=i#> different type cases
    /// </summary>
#else
	/// <summary>
    /// A generic type-safe discriminated union with <#=i#> different type cases
    /// </summary>
#endif
	public abstract class Union<<#=type_str#>>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
<#
for (int j = 0; j < i; j++)
{
#>
        /// <param name="<#=SmallC(j)#>">A function which matches the union type '<#=BigC(j)#>'</param>
<# } #>
        public abstract void Match(<#=act_str#>);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
<#
for (int j = 0; j < i; j++)
{
#>
        /// <param name="<#=SmallC(j)#>">A function which matches the union type '<#=BigC(j)#>'</param>
<# } #>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(<#=func_str#>);
#if UNSAFE
<#
for (int j = 0; j < i; j++)
{
#>
        /// <summary>
        /// Returns, whether the current union instance is from the type '<#=BigC(j)#>'
        /// </summary>
		public virtual bool Is<#=BigC(j)#> => false;
<#
}
for (int j = 0; j < i; j++)
{
#>
        /// <summary>
		/// Returns the union value cast to the type '<#=BigC(j)#>'
        /// </summary>
		public <#=BigC(j)#> As<#=BigC(j)#> => As<<#=BigC(j)#>>();
<# } #>
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
<#= string.Join(" ||\r\n", from j in Enumerable.Range(0, i) select $"			{(j == 0 ? '(' : ' ')}(typeof(_) == typeof({BigC(j)}))")#>) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
<#
for (int j = 0; j < i; j++)
{
#>
		public static implicit operator <#=BigC(j)#>(Union<<#=type_str#>> u) => u.As<<#=BigC(j)#>>();
<#
}
#>
#endif
<#
for (int j = 0; j < i; j++)
{
#>
		public static implicit operator Union<<#=type_str#>>(<#=BigC(j)#> i) => new Case<#=j + 1#>(i);
<# } #>

<#
for (int j = 0; j < i; j++)
{
#>
        /// <summary>
        /// Union case №<#=j + 1#> (Represents type '<#=BigC(j)#>')
        /// </summary>
		public sealed class Case<#=j + 1#>
			: Union<#=""#><<#=type_str#>>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type '<#=BigC(j)#>'
			/// </summary>
			public override bool Is<#=BigC(j)#> => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public <#=BigC(j)#> Item { get; }

			public override _ Match<_>(<#=func_str#>) => <#=SmallC(j)#>(Item);
			
			public override void Match(<#=act_str#>) => <#=SmallC(j)#>(Item);

			/// <summary>
            /// Creates a new union with '<#=i#>' possible cases and sets it to a value of the type '<#=BigC(j)#>'
            /// </summary>
            /// <param name="item">Union value of the type <#=BigC(j)#></param>
            public Case<#=j + 1#>(<#=BigC(j)#> item)
				: base() => Item = item;

			public static implicit operator <#=BigC(j)#>(Case<#=j + 1#> c) => c.Item;
			public static implicit operator Case<#=j + 1#>(<#=BigC(j)#> i) => new Case<#=j + 1#>(i);
		}
<# } #>
	}
<# } #>
}
