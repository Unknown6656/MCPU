// maybe (hopefully) this code file will be obsolete in C# 8
// Autogenerated  2016-12-25 20:36:06:415751

using System;

namespace MCPU.Compiler
{

	/// <summary>
    /// A generic discriminated union with 2 different type cases
    /// </summary>
	public abstract class Union<A, B>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b);

		private Union() { }


		public sealed class Case1
			: Union<A, B>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 3 different type cases
    /// </summary>
	public abstract class Union<A, B, C>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 4 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 5 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 6 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 7 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 8 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 9 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}

		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I>
		{
			public I Item { get; }
			
            public Case9(I item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i) => i(Item);

			public static implicit operator I(Case9 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 10 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}

		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
			public I Item { get; }
			
            public Case9(I item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => i(Item);

			public static implicit operator I(Case9 c) => c.Item;
		}

		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
			public J Item { get; }
			
            public Case10(J item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => j(Item);

			public static implicit operator J(Case10 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 11 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}

		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
			public I Item { get; }
			
            public Case9(I item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => i(Item);

			public static implicit operator I(Case9 c) => c.Item;
		}

		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
			public J Item { get; }
			
            public Case10(J item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => j(Item);

			public static implicit operator J(Case10 c) => c.Item;
		}

		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
			public K Item { get; }
			
            public Case11(K item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => k(Item);

			public static implicit operator K(Case11 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 12 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}

		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
			public I Item { get; }
			
            public Case9(I item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => i(Item);

			public static implicit operator I(Case9 c) => c.Item;
		}

		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
			public J Item { get; }
			
            public Case10(J item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => j(Item);

			public static implicit operator J(Case10 c) => c.Item;
		}

		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
			public K Item { get; }
			
            public Case11(K item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => k(Item);

			public static implicit operator K(Case11 c) => c.Item;
		}

		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
			public L Item { get; }
			
            public Case12(L item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => l(Item);

			public static implicit operator L(Case12 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 13 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}

		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
			public I Item { get; }
			
            public Case9(I item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => i(Item);

			public static implicit operator I(Case9 c) => c.Item;
		}

		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
			public J Item { get; }
			
            public Case10(J item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => j(Item);

			public static implicit operator J(Case10 c) => c.Item;
		}

		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
			public K Item { get; }
			
            public Case11(K item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => k(Item);

			public static implicit operator K(Case11 c) => c.Item;
		}

		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
			public L Item { get; }
			
            public Case12(L item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => l(Item);

			public static implicit operator L(Case12 c) => c.Item;
		}

		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
			public M Item { get; }
			
            public Case13(M item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => m(Item);

			public static implicit operator M(Case13 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 14 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}

		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
			public I Item { get; }
			
            public Case9(I item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => i(Item);

			public static implicit operator I(Case9 c) => c.Item;
		}

		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
			public J Item { get; }
			
            public Case10(J item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => j(Item);

			public static implicit operator J(Case10 c) => c.Item;
		}

		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
			public K Item { get; }
			
            public Case11(K item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => k(Item);

			public static implicit operator K(Case11 c) => c.Item;
		}

		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
			public L Item { get; }
			
            public Case12(L item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => l(Item);

			public static implicit operator L(Case12 c) => c.Item;
		}

		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
			public M Item { get; }
			
            public Case13(M item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => m(Item);

			public static implicit operator M(Case13 c) => c.Item;
		}

		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
			public N Item { get; }
			
            public Case14(N item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => n(Item);

			public static implicit operator N(Case14 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 15 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}

		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
			public I Item { get; }
			
            public Case9(I item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => i(Item);

			public static implicit operator I(Case9 c) => c.Item;
		}

		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
			public J Item { get; }
			
            public Case10(J item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => j(Item);

			public static implicit operator J(Case10 c) => c.Item;
		}

		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
			public K Item { get; }
			
            public Case11(K item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => k(Item);

			public static implicit operator K(Case11 c) => c.Item;
		}

		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
			public L Item { get; }
			
            public Case12(L item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => l(Item);

			public static implicit operator L(Case12 c) => c.Item;
		}

		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
			public M Item { get; }
			
            public Case13(M item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => m(Item);

			public static implicit operator M(Case13 c) => c.Item;
		}

		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
			public N Item { get; }
			
            public Case14(N item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => n(Item);

			public static implicit operator N(Case14 c) => c.Item;
		}

		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
			public O Item { get; }
			
            public Case15(O item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => o(Item);

			public static implicit operator O(Case15 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 16 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}

		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
			public I Item { get; }
			
            public Case9(I item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => i(Item);

			public static implicit operator I(Case9 c) => c.Item;
		}

		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
			public J Item { get; }
			
            public Case10(J item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => j(Item);

			public static implicit operator J(Case10 c) => c.Item;
		}

		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
			public K Item { get; }
			
            public Case11(K item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => k(Item);

			public static implicit operator K(Case11 c) => c.Item;
		}

		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
			public L Item { get; }
			
            public Case12(L item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => l(Item);

			public static implicit operator L(Case12 c) => c.Item;
		}

		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
			public M Item { get; }
			
            public Case13(M item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => m(Item);

			public static implicit operator M(Case13 c) => c.Item;
		}

		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
			public N Item { get; }
			
            public Case14(N item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => n(Item);

			public static implicit operator N(Case14 c) => c.Item;
		}

		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
			public O Item { get; }
			
            public Case15(O item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => o(Item);

			public static implicit operator O(Case15 c) => c.Item;
		}

		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
			public P Item { get; }
			
            public Case16(P item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => p(Item);

			public static implicit operator P(Case16 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 17 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}

		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
			public I Item { get; }
			
            public Case9(I item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => i(Item);

			public static implicit operator I(Case9 c) => c.Item;
		}

		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
			public J Item { get; }
			
            public Case10(J item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => j(Item);

			public static implicit operator J(Case10 c) => c.Item;
		}

		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
			public K Item { get; }
			
            public Case11(K item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => k(Item);

			public static implicit operator K(Case11 c) => c.Item;
		}

		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
			public L Item { get; }
			
            public Case12(L item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => l(Item);

			public static implicit operator L(Case12 c) => c.Item;
		}

		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
			public M Item { get; }
			
            public Case13(M item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => m(Item);

			public static implicit operator M(Case13 c) => c.Item;
		}

		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
			public N Item { get; }
			
            public Case14(N item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => n(Item);

			public static implicit operator N(Case14 c) => c.Item;
		}

		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
			public O Item { get; }
			
            public Case15(O item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => o(Item);

			public static implicit operator O(Case15 c) => c.Item;
		}

		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
			public P Item { get; }
			
            public Case16(P item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => p(Item);

			public static implicit operator P(Case16 c) => c.Item;
		}

		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
			public Q Item { get; }
			
            public Case17(Q item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => q(Item);

			public static implicit operator Q(Case17 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 18 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}

		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
			public I Item { get; }
			
            public Case9(I item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => i(Item);

			public static implicit operator I(Case9 c) => c.Item;
		}

		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
			public J Item { get; }
			
            public Case10(J item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => j(Item);

			public static implicit operator J(Case10 c) => c.Item;
		}

		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
			public K Item { get; }
			
            public Case11(K item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => k(Item);

			public static implicit operator K(Case11 c) => c.Item;
		}

		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
			public L Item { get; }
			
            public Case12(L item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => l(Item);

			public static implicit operator L(Case12 c) => c.Item;
		}

		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
			public M Item { get; }
			
            public Case13(M item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => m(Item);

			public static implicit operator M(Case13 c) => c.Item;
		}

		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
			public N Item { get; }
			
            public Case14(N item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => n(Item);

			public static implicit operator N(Case14 c) => c.Item;
		}

		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
			public O Item { get; }
			
            public Case15(O item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => o(Item);

			public static implicit operator O(Case15 c) => c.Item;
		}

		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
			public P Item { get; }
			
            public Case16(P item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => p(Item);

			public static implicit operator P(Case16 c) => c.Item;
		}

		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
			public Q Item { get; }
			
            public Case17(Q item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => q(Item);

			public static implicit operator Q(Case17 c) => c.Item;
		}

		public sealed class Case18
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
			public R Item { get; }
			
            public Case18(R item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => r(Item);

			public static implicit operator R(Case18 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 19 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}

		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public I Item { get; }
			
            public Case9(I item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => i(Item);

			public static implicit operator I(Case9 c) => c.Item;
		}

		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public J Item { get; }
			
            public Case10(J item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => j(Item);

			public static implicit operator J(Case10 c) => c.Item;
		}

		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public K Item { get; }
			
            public Case11(K item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => k(Item);

			public static implicit operator K(Case11 c) => c.Item;
		}

		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public L Item { get; }
			
            public Case12(L item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => l(Item);

			public static implicit operator L(Case12 c) => c.Item;
		}

		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public M Item { get; }
			
            public Case13(M item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => m(Item);

			public static implicit operator M(Case13 c) => c.Item;
		}

		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public N Item { get; }
			
            public Case14(N item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => n(Item);

			public static implicit operator N(Case14 c) => c.Item;
		}

		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public O Item { get; }
			
            public Case15(O item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => o(Item);

			public static implicit operator O(Case15 c) => c.Item;
		}

		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public P Item { get; }
			
            public Case16(P item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => p(Item);

			public static implicit operator P(Case16 c) => c.Item;
		}

		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public Q Item { get; }
			
            public Case17(Q item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => q(Item);

			public static implicit operator Q(Case17 c) => c.Item;
		}

		public sealed class Case18
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public R Item { get; }
			
            public Case18(R item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => r(Item);

			public static implicit operator R(Case18 c) => c.Item;
		}

		public sealed class Case19
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
			public S Item { get; }
			
            public Case19(S item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => s(Item);

			public static implicit operator S(Case19 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 20 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}

		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public I Item { get; }
			
            public Case9(I item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => i(Item);

			public static implicit operator I(Case9 c) => c.Item;
		}

		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public J Item { get; }
			
            public Case10(J item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => j(Item);

			public static implicit operator J(Case10 c) => c.Item;
		}

		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public K Item { get; }
			
            public Case11(K item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => k(Item);

			public static implicit operator K(Case11 c) => c.Item;
		}

		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public L Item { get; }
			
            public Case12(L item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => l(Item);

			public static implicit operator L(Case12 c) => c.Item;
		}

		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public M Item { get; }
			
            public Case13(M item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => m(Item);

			public static implicit operator M(Case13 c) => c.Item;
		}

		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public N Item { get; }
			
            public Case14(N item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => n(Item);

			public static implicit operator N(Case14 c) => c.Item;
		}

		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public O Item { get; }
			
            public Case15(O item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => o(Item);

			public static implicit operator O(Case15 c) => c.Item;
		}

		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public P Item { get; }
			
            public Case16(P item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => p(Item);

			public static implicit operator P(Case16 c) => c.Item;
		}

		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public Q Item { get; }
			
            public Case17(Q item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => q(Item);

			public static implicit operator Q(Case17 c) => c.Item;
		}

		public sealed class Case18
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public R Item { get; }
			
            public Case18(R item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => r(Item);

			public static implicit operator R(Case18 c) => c.Item;
		}

		public sealed class Case19
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public S Item { get; }
			
            public Case19(S item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => s(Item);

			public static implicit operator S(Case19 c) => c.Item;
		}

		public sealed class Case20
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
			public T Item { get; }
			
            public Case20(T item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => t(Item);

			public static implicit operator T(Case20 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 21 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}

		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public I Item { get; }
			
            public Case9(I item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => i(Item);

			public static implicit operator I(Case9 c) => c.Item;
		}

		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public J Item { get; }
			
            public Case10(J item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => j(Item);

			public static implicit operator J(Case10 c) => c.Item;
		}

		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public K Item { get; }
			
            public Case11(K item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => k(Item);

			public static implicit operator K(Case11 c) => c.Item;
		}

		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public L Item { get; }
			
            public Case12(L item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => l(Item);

			public static implicit operator L(Case12 c) => c.Item;
		}

		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public M Item { get; }
			
            public Case13(M item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => m(Item);

			public static implicit operator M(Case13 c) => c.Item;
		}

		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public N Item { get; }
			
            public Case14(N item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => n(Item);

			public static implicit operator N(Case14 c) => c.Item;
		}

		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public O Item { get; }
			
            public Case15(O item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => o(Item);

			public static implicit operator O(Case15 c) => c.Item;
		}

		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public P Item { get; }
			
            public Case16(P item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => p(Item);

			public static implicit operator P(Case16 c) => c.Item;
		}

		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public Q Item { get; }
			
            public Case17(Q item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => q(Item);

			public static implicit operator Q(Case17 c) => c.Item;
		}

		public sealed class Case18
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public R Item { get; }
			
            public Case18(R item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => r(Item);

			public static implicit operator R(Case18 c) => c.Item;
		}

		public sealed class Case19
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public S Item { get; }
			
            public Case19(S item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => s(Item);

			public static implicit operator S(Case19 c) => c.Item;
		}

		public sealed class Case20
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public T Item { get; }
			
            public Case20(T item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => t(Item);

			public static implicit operator T(Case20 c) => c.Item;
		}

		public sealed class Case21
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
			public U Item { get; }
			
            public Case21(U item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => u(Item);

			public static implicit operator U(Case21 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 22 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}

		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public I Item { get; }
			
            public Case9(I item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => i(Item);

			public static implicit operator I(Case9 c) => c.Item;
		}

		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public J Item { get; }
			
            public Case10(J item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => j(Item);

			public static implicit operator J(Case10 c) => c.Item;
		}

		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public K Item { get; }
			
            public Case11(K item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => k(Item);

			public static implicit operator K(Case11 c) => c.Item;
		}

		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public L Item { get; }
			
            public Case12(L item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => l(Item);

			public static implicit operator L(Case12 c) => c.Item;
		}

		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public M Item { get; }
			
            public Case13(M item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => m(Item);

			public static implicit operator M(Case13 c) => c.Item;
		}

		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public N Item { get; }
			
            public Case14(N item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => n(Item);

			public static implicit operator N(Case14 c) => c.Item;
		}

		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public O Item { get; }
			
            public Case15(O item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => o(Item);

			public static implicit operator O(Case15 c) => c.Item;
		}

		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public P Item { get; }
			
            public Case16(P item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => p(Item);

			public static implicit operator P(Case16 c) => c.Item;
		}

		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public Q Item { get; }
			
            public Case17(Q item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => q(Item);

			public static implicit operator Q(Case17 c) => c.Item;
		}

		public sealed class Case18
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public R Item { get; }
			
            public Case18(R item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => r(Item);

			public static implicit operator R(Case18 c) => c.Item;
		}

		public sealed class Case19
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public S Item { get; }
			
            public Case19(S item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => s(Item);

			public static implicit operator S(Case19 c) => c.Item;
		}

		public sealed class Case20
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public T Item { get; }
			
            public Case20(T item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => t(Item);

			public static implicit operator T(Case20 c) => c.Item;
		}

		public sealed class Case21
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public U Item { get; }
			
            public Case21(U item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => u(Item);

			public static implicit operator U(Case21 c) => c.Item;
		}

		public sealed class Case22
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
			public V Item { get; }
			
            public Case22(V item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => v(Item);

			public static implicit operator V(Case22 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 23 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}

		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public I Item { get; }
			
            public Case9(I item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => i(Item);

			public static implicit operator I(Case9 c) => c.Item;
		}

		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public J Item { get; }
			
            public Case10(J item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => j(Item);

			public static implicit operator J(Case10 c) => c.Item;
		}

		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public K Item { get; }
			
            public Case11(K item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => k(Item);

			public static implicit operator K(Case11 c) => c.Item;
		}

		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public L Item { get; }
			
            public Case12(L item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => l(Item);

			public static implicit operator L(Case12 c) => c.Item;
		}

		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public M Item { get; }
			
            public Case13(M item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => m(Item);

			public static implicit operator M(Case13 c) => c.Item;
		}

		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public N Item { get; }
			
            public Case14(N item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => n(Item);

			public static implicit operator N(Case14 c) => c.Item;
		}

		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public O Item { get; }
			
            public Case15(O item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => o(Item);

			public static implicit operator O(Case15 c) => c.Item;
		}

		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public P Item { get; }
			
            public Case16(P item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => p(Item);

			public static implicit operator P(Case16 c) => c.Item;
		}

		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public Q Item { get; }
			
            public Case17(Q item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => q(Item);

			public static implicit operator Q(Case17 c) => c.Item;
		}

		public sealed class Case18
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public R Item { get; }
			
            public Case18(R item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => r(Item);

			public static implicit operator R(Case18 c) => c.Item;
		}

		public sealed class Case19
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public S Item { get; }
			
            public Case19(S item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => s(Item);

			public static implicit operator S(Case19 c) => c.Item;
		}

		public sealed class Case20
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public T Item { get; }
			
            public Case20(T item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => t(Item);

			public static implicit operator T(Case20 c) => c.Item;
		}

		public sealed class Case21
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public U Item { get; }
			
            public Case21(U item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => u(Item);

			public static implicit operator U(Case21 c) => c.Item;
		}

		public sealed class Case22
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public V Item { get; }
			
            public Case22(V item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => v(Item);

			public static implicit operator V(Case22 c) => c.Item;
		}

		public sealed class Case23
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
			public W Item { get; }
			
            public Case23(W item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => w(Item);

			public static implicit operator W(Case23 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 24 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}

		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public I Item { get; }
			
            public Case9(I item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => i(Item);

			public static implicit operator I(Case9 c) => c.Item;
		}

		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public J Item { get; }
			
            public Case10(J item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => j(Item);

			public static implicit operator J(Case10 c) => c.Item;
		}

		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public K Item { get; }
			
            public Case11(K item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => k(Item);

			public static implicit operator K(Case11 c) => c.Item;
		}

		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public L Item { get; }
			
            public Case12(L item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => l(Item);

			public static implicit operator L(Case12 c) => c.Item;
		}

		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public M Item { get; }
			
            public Case13(M item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => m(Item);

			public static implicit operator M(Case13 c) => c.Item;
		}

		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public N Item { get; }
			
            public Case14(N item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => n(Item);

			public static implicit operator N(Case14 c) => c.Item;
		}

		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public O Item { get; }
			
            public Case15(O item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => o(Item);

			public static implicit operator O(Case15 c) => c.Item;
		}

		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public P Item { get; }
			
            public Case16(P item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => p(Item);

			public static implicit operator P(Case16 c) => c.Item;
		}

		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public Q Item { get; }
			
            public Case17(Q item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => q(Item);

			public static implicit operator Q(Case17 c) => c.Item;
		}

		public sealed class Case18
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public R Item { get; }
			
            public Case18(R item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => r(Item);

			public static implicit operator R(Case18 c) => c.Item;
		}

		public sealed class Case19
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public S Item { get; }
			
            public Case19(S item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => s(Item);

			public static implicit operator S(Case19 c) => c.Item;
		}

		public sealed class Case20
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public T Item { get; }
			
            public Case20(T item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => t(Item);

			public static implicit operator T(Case20 c) => c.Item;
		}

		public sealed class Case21
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public U Item { get; }
			
            public Case21(U item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => u(Item);

			public static implicit operator U(Case21 c) => c.Item;
		}

		public sealed class Case22
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public V Item { get; }
			
            public Case22(V item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => v(Item);

			public static implicit operator V(Case22 c) => c.Item;
		}

		public sealed class Case23
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public W Item { get; }
			
            public Case23(W item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => w(Item);

			public static implicit operator W(Case23 c) => c.Item;
		}

		public sealed class Case24
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
			public X Item { get; }
			
            public Case24(X item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => x(Item);

			public static implicit operator X(Case24 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 25 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}

		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public I Item { get; }
			
            public Case9(I item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => i(Item);

			public static implicit operator I(Case9 c) => c.Item;
		}

		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public J Item { get; }
			
            public Case10(J item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => j(Item);

			public static implicit operator J(Case10 c) => c.Item;
		}

		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public K Item { get; }
			
            public Case11(K item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => k(Item);

			public static implicit operator K(Case11 c) => c.Item;
		}

		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public L Item { get; }
			
            public Case12(L item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => l(Item);

			public static implicit operator L(Case12 c) => c.Item;
		}

		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public M Item { get; }
			
            public Case13(M item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => m(Item);

			public static implicit operator M(Case13 c) => c.Item;
		}

		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public N Item { get; }
			
            public Case14(N item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => n(Item);

			public static implicit operator N(Case14 c) => c.Item;
		}

		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public O Item { get; }
			
            public Case15(O item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => o(Item);

			public static implicit operator O(Case15 c) => c.Item;
		}

		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public P Item { get; }
			
            public Case16(P item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => p(Item);

			public static implicit operator P(Case16 c) => c.Item;
		}

		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public Q Item { get; }
			
            public Case17(Q item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => q(Item);

			public static implicit operator Q(Case17 c) => c.Item;
		}

		public sealed class Case18
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public R Item { get; }
			
            public Case18(R item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => r(Item);

			public static implicit operator R(Case18 c) => c.Item;
		}

		public sealed class Case19
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public S Item { get; }
			
            public Case19(S item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => s(Item);

			public static implicit operator S(Case19 c) => c.Item;
		}

		public sealed class Case20
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public T Item { get; }
			
            public Case20(T item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => t(Item);

			public static implicit operator T(Case20 c) => c.Item;
		}

		public sealed class Case21
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public U Item { get; }
			
            public Case21(U item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => u(Item);

			public static implicit operator U(Case21 c) => c.Item;
		}

		public sealed class Case22
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public V Item { get; }
			
            public Case22(V item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => v(Item);

			public static implicit operator V(Case22 c) => c.Item;
		}

		public sealed class Case23
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public W Item { get; }
			
            public Case23(W item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => w(Item);

			public static implicit operator W(Case23 c) => c.Item;
		}

		public sealed class Case24
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public X Item { get; }
			
            public Case24(X item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => x(Item);

			public static implicit operator X(Case24 c) => c.Item;
		}

		public sealed class Case25
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
			public Y Item { get; }
			
            public Case25(Y item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => y(Item);

			public static implicit operator Y(Case25 c) => c.Item;
		}
	}

	/// <summary>
    /// A generic discriminated union with 26 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
    {
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z);

		private Union() { }


		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public A Item { get; }
			
            public Case1(A item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => a(Item);

			public static implicit operator A(Case1 c) => c.Item;
		}

		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public B Item { get; }
			
            public Case2(B item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => b(Item);

			public static implicit operator B(Case2 c) => c.Item;
		}

		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public C Item { get; }
			
            public Case3(C item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => c(Item);

			public static implicit operator C(Case3 c) => c.Item;
		}

		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public D Item { get; }
			
            public Case4(D item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => d(Item);

			public static implicit operator D(Case4 c) => c.Item;
		}

		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public E Item { get; }
			
            public Case5(E item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => e(Item);

			public static implicit operator E(Case5 c) => c.Item;
		}

		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public F Item { get; }
			
            public Case6(F item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => f(Item);

			public static implicit operator F(Case6 c) => c.Item;
		}

		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public G Item { get; }
			
            public Case7(G item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => g(Item);

			public static implicit operator G(Case7 c) => c.Item;
		}

		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public H Item { get; }
			
            public Case8(H item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => h(Item);

			public static implicit operator H(Case8 c) => c.Item;
		}

		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public I Item { get; }
			
            public Case9(I item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => i(Item);

			public static implicit operator I(Case9 c) => c.Item;
		}

		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public J Item { get; }
			
            public Case10(J item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => j(Item);

			public static implicit operator J(Case10 c) => c.Item;
		}

		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public K Item { get; }
			
            public Case11(K item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => k(Item);

			public static implicit operator K(Case11 c) => c.Item;
		}

		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public L Item { get; }
			
            public Case12(L item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => l(Item);

			public static implicit operator L(Case12 c) => c.Item;
		}

		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public M Item { get; }
			
            public Case13(M item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => m(Item);

			public static implicit operator M(Case13 c) => c.Item;
		}

		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public N Item { get; }
			
            public Case14(N item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => n(Item);

			public static implicit operator N(Case14 c) => c.Item;
		}

		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public O Item { get; }
			
            public Case15(O item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => o(Item);

			public static implicit operator O(Case15 c) => c.Item;
		}

		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public P Item { get; }
			
            public Case16(P item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => p(Item);

			public static implicit operator P(Case16 c) => c.Item;
		}

		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public Q Item { get; }
			
            public Case17(Q item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => q(Item);

			public static implicit operator Q(Case17 c) => c.Item;
		}

		public sealed class Case18
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public R Item { get; }
			
            public Case18(R item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => r(Item);

			public static implicit operator R(Case18 c) => c.Item;
		}

		public sealed class Case19
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public S Item { get; }
			
            public Case19(S item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => s(Item);

			public static implicit operator S(Case19 c) => c.Item;
		}

		public sealed class Case20
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public T Item { get; }
			
            public Case20(T item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => t(Item);

			public static implicit operator T(Case20 c) => c.Item;
		}

		public sealed class Case21
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public U Item { get; }
			
            public Case21(U item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => u(Item);

			public static implicit operator U(Case21 c) => c.Item;
		}

		public sealed class Case22
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public V Item { get; }
			
            public Case22(V item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => v(Item);

			public static implicit operator V(Case22 c) => c.Item;
		}

		public sealed class Case23
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public W Item { get; }
			
            public Case23(W item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => w(Item);

			public static implicit operator W(Case23 c) => c.Item;
		}

		public sealed class Case24
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public X Item { get; }
			
            public Case24(X item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => x(Item);

			public static implicit operator X(Case24 c) => c.Item;
		}

		public sealed class Case25
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public Y Item { get; }
			
            public Case25(Y item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => y(Item);

			public static implicit operator Y(Case25 c) => c.Item;
		}

		public sealed class Case26
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
			public Z Item { get; }
			
            public Case26(Z item)
				: base() => Item = item;

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => z(Item);

			public static implicit operator Z(Case26 c) => c.Item;
		}
	}
}
