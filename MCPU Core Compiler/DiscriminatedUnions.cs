#define SILENT
#define UNSAFE

// maybe (hopefully) this code file will be obsolete in C# 8
// Autogenerated  2017-01-13 11:50:18:464544   (UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna

using System;

namespace MCPU.Compiler
{
#if UNSAFE
	/// <summary>
    /// An interface for discriminated type-unsafe unions
    /// </summary>
    public interface IUnsafeUnion
    {
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
        _ As<_>();
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
        bool Is<_>();
		/// <summary>
        /// The union's type-unsafe item
		/// </summary>
        object UnsafeItem { get; }
    }
#endif

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 2 different type cases
    /// </summary>
	public abstract class Union<A, B>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        public abstract void Match(Action<A> a, Action<B> b);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B> u) => u.As<A>();
		public static implicit operator B(Union<A, B> u) => u.As<B>();
#endif
		public static implicit operator Union<A, B>(A i) => new Case1(i);
		public static implicit operator Union<A, B>(B i) => new Case2(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b) => a(Item);

			/// <summary>
            /// Creates a new union with '2' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b) => b(Item);

			/// <summary>
            /// Creates a new union with '2' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 3 different type cases
    /// </summary>
	public abstract class Union<A, B, C>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C> u) => u.As<C>();
#endif
		public static implicit operator Union<A, B, C>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C>(C i) => new Case3(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c) => a(Item);

			/// <summary>
            /// Creates a new union with '3' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c) => b(Item);

			/// <summary>
            /// Creates a new union with '3' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c) => c(Item);

			/// <summary>
            /// Creates a new union with '3' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 4 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D> u) => u.As<D>();
#endif
		public static implicit operator Union<A, B, C, D>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D>(D i) => new Case4(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d) => a(Item);

			/// <summary>
            /// Creates a new union with '4' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d) => b(Item);

			/// <summary>
            /// Creates a new union with '4' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d) => c(Item);

			/// <summary>
            /// Creates a new union with '4' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d) => d(Item);

			/// <summary>
            /// Creates a new union with '4' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 5 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E> u) => u.As<E>();
#endif
		public static implicit operator Union<A, B, C, D, E>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E>(E i) => new Case5(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e) => a(Item);

			/// <summary>
            /// Creates a new union with '5' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e) => b(Item);

			/// <summary>
            /// Creates a new union with '5' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e) => c(Item);

			/// <summary>
            /// Creates a new union with '5' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e) => d(Item);

			/// <summary>
            /// Creates a new union with '5' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e) => e(Item);

			/// <summary>
            /// Creates a new union with '5' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 6 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F> u) => u.As<F>();
#endif
		public static implicit operator Union<A, B, C, D, E, F>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F>(F i) => new Case6(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f) => a(Item);

			/// <summary>
            /// Creates a new union with '6' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f) => b(Item);

			/// <summary>
            /// Creates a new union with '6' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f) => c(Item);

			/// <summary>
            /// Creates a new union with '6' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f) => d(Item);

			/// <summary>
            /// Creates a new union with '6' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f) => e(Item);

			/// <summary>
            /// Creates a new union with '6' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f) => f(Item);

			/// <summary>
            /// Creates a new union with '6' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 7 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G> u) => u.As<G>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G>(G i) => new Case7(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g) => a(Item);

			/// <summary>
            /// Creates a new union with '7' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g) => b(Item);

			/// <summary>
            /// Creates a new union with '7' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g) => c(Item);

			/// <summary>
            /// Creates a new union with '7' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g) => d(Item);

			/// <summary>
            /// Creates a new union with '7' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g) => e(Item);

			/// <summary>
            /// Creates a new union with '7' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g) => f(Item);

			/// <summary>
            /// Creates a new union with '7' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g) => g(Item);

			/// <summary>
            /// Creates a new union with '7' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 8 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H> u) => u.As<H>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H>(H i) => new Case8(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h) => a(Item);

			/// <summary>
            /// Creates a new union with '8' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h) => b(Item);

			/// <summary>
            /// Creates a new union with '8' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h) => c(Item);

			/// <summary>
            /// Creates a new union with '8' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h) => d(Item);

			/// <summary>
            /// Creates a new union with '8' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h) => e(Item);

			/// <summary>
            /// Creates a new union with '8' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h) => f(Item);

			/// <summary>
            /// Creates a new union with '8' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h) => g(Item);

			/// <summary>
            /// Creates a new union with '8' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h) => h(Item);

			/// <summary>
            /// Creates a new union with '8' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 9 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'I'
        /// </summary>
		public virtual bool IsI => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
		/// Returns the union value cast to the type 'I'
        /// </summary>
		public I AsI => As<I>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H)) ||
			 (typeof(_) == typeof(I))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H, I> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H, I> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H, I> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H, I> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H, I> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H, I> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H, I> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H, I> u) => u.As<H>();
		public static implicit operator I(Union<A, B, C, D, E, F, G, H, I> u) => u.As<I>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H, I>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I>(H i) => new Case8(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I>(I i) => new Case9(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i) => a(Item);

			/// <summary>
            /// Creates a new union with '9' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i) => b(Item);

			/// <summary>
            /// Creates a new union with '9' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i) => c(Item);

			/// <summary>
            /// Creates a new union with '9' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i) => d(Item);

			/// <summary>
            /// Creates a new union with '9' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i) => e(Item);

			/// <summary>
            /// Creates a new union with '9' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i) => f(Item);

			/// <summary>
            /// Creates a new union with '9' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i) => g(Item);

			/// <summary>
            /// Creates a new union with '9' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i) => h(Item);

			/// <summary>
            /// Creates a new union with '9' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
        /// <summary>
        /// Union case №9 (Represents type 'I')
        /// </summary>
		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'I'
			/// </summary>
			public override bool IsI => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public I Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i) => i(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i) => i(Item);

			/// <summary>
            /// Creates a new union with '9' possible cases and sets it to a value of the type 'I'
            /// </summary>
            /// <param name="item">Union value of the type I</param>
            public Case9(I item)
				: base() => Item = item;

			public static implicit operator I(Case9 c) => c.Item;
			public static implicit operator Case9(I i) => new Case9(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 10 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'I'
        /// </summary>
		public virtual bool IsI => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'J'
        /// </summary>
		public virtual bool IsJ => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
		/// Returns the union value cast to the type 'I'
        /// </summary>
		public I AsI => As<I>();
        /// <summary>
		/// Returns the union value cast to the type 'J'
        /// </summary>
		public J AsJ => As<J>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H)) ||
			 (typeof(_) == typeof(I)) ||
			 (typeof(_) == typeof(J))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H, I, J> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H, I, J> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H, I, J> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H, I, J> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H, I, J> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H, I, J> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H, I, J> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H, I, J> u) => u.As<H>();
		public static implicit operator I(Union<A, B, C, D, E, F, G, H, I, J> u) => u.As<I>();
		public static implicit operator J(Union<A, B, C, D, E, F, G, H, I, J> u) => u.As<J>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J>(H i) => new Case8(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J>(I i) => new Case9(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J>(J i) => new Case10(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j) => a(Item);

			/// <summary>
            /// Creates a new union with '10' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j) => b(Item);

			/// <summary>
            /// Creates a new union with '10' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j) => c(Item);

			/// <summary>
            /// Creates a new union with '10' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j) => d(Item);

			/// <summary>
            /// Creates a new union with '10' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j) => e(Item);

			/// <summary>
            /// Creates a new union with '10' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j) => f(Item);

			/// <summary>
            /// Creates a new union with '10' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j) => g(Item);

			/// <summary>
            /// Creates a new union with '10' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j) => h(Item);

			/// <summary>
            /// Creates a new union with '10' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
        /// <summary>
        /// Union case №9 (Represents type 'I')
        /// </summary>
		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'I'
			/// </summary>
			public override bool IsI => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public I Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => i(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j) => i(Item);

			/// <summary>
            /// Creates a new union with '10' possible cases and sets it to a value of the type 'I'
            /// </summary>
            /// <param name="item">Union value of the type I</param>
            public Case9(I item)
				: base() => Item = item;

			public static implicit operator I(Case9 c) => c.Item;
			public static implicit operator Case9(I i) => new Case9(i);
		}
        /// <summary>
        /// Union case №10 (Represents type 'J')
        /// </summary>
		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'J'
			/// </summary>
			public override bool IsJ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public J Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j) => j(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j) => j(Item);

			/// <summary>
            /// Creates a new union with '10' possible cases and sets it to a value of the type 'J'
            /// </summary>
            /// <param name="item">Union value of the type J</param>
            public Case10(J item)
				: base() => Item = item;

			public static implicit operator J(Case10 c) => c.Item;
			public static implicit operator Case10(J i) => new Case10(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 11 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'I'
        /// </summary>
		public virtual bool IsI => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'J'
        /// </summary>
		public virtual bool IsJ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'K'
        /// </summary>
		public virtual bool IsK => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
		/// Returns the union value cast to the type 'I'
        /// </summary>
		public I AsI => As<I>();
        /// <summary>
		/// Returns the union value cast to the type 'J'
        /// </summary>
		public J AsJ => As<J>();
        /// <summary>
		/// Returns the union value cast to the type 'K'
        /// </summary>
		public K AsK => As<K>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H)) ||
			 (typeof(_) == typeof(I)) ||
			 (typeof(_) == typeof(J)) ||
			 (typeof(_) == typeof(K))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H, I, J, K> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H, I, J, K> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H, I, J, K> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H, I, J, K> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H, I, J, K> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H, I, J, K> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H, I, J, K> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H, I, J, K> u) => u.As<H>();
		public static implicit operator I(Union<A, B, C, D, E, F, G, H, I, J, K> u) => u.As<I>();
		public static implicit operator J(Union<A, B, C, D, E, F, G, H, I, J, K> u) => u.As<J>();
		public static implicit operator K(Union<A, B, C, D, E, F, G, H, I, J, K> u) => u.As<K>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K>(H i) => new Case8(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K>(I i) => new Case9(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K>(J i) => new Case10(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K>(K i) => new Case11(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k) => a(Item);

			/// <summary>
            /// Creates a new union with '11' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k) => b(Item);

			/// <summary>
            /// Creates a new union with '11' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k) => c(Item);

			/// <summary>
            /// Creates a new union with '11' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k) => d(Item);

			/// <summary>
            /// Creates a new union with '11' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k) => e(Item);

			/// <summary>
            /// Creates a new union with '11' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k) => f(Item);

			/// <summary>
            /// Creates a new union with '11' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k) => g(Item);

			/// <summary>
            /// Creates a new union with '11' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k) => h(Item);

			/// <summary>
            /// Creates a new union with '11' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
        /// <summary>
        /// Union case №9 (Represents type 'I')
        /// </summary>
		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'I'
			/// </summary>
			public override bool IsI => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public I Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => i(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k) => i(Item);

			/// <summary>
            /// Creates a new union with '11' possible cases and sets it to a value of the type 'I'
            /// </summary>
            /// <param name="item">Union value of the type I</param>
            public Case9(I item)
				: base() => Item = item;

			public static implicit operator I(Case9 c) => c.Item;
			public static implicit operator Case9(I i) => new Case9(i);
		}
        /// <summary>
        /// Union case №10 (Represents type 'J')
        /// </summary>
		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'J'
			/// </summary>
			public override bool IsJ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public J Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => j(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k) => j(Item);

			/// <summary>
            /// Creates a new union with '11' possible cases and sets it to a value of the type 'J'
            /// </summary>
            /// <param name="item">Union value of the type J</param>
            public Case10(J item)
				: base() => Item = item;

			public static implicit operator J(Case10 c) => c.Item;
			public static implicit operator Case10(J i) => new Case10(i);
		}
        /// <summary>
        /// Union case №11 (Represents type 'K')
        /// </summary>
		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'K'
			/// </summary>
			public override bool IsK => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public K Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k) => k(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k) => k(Item);

			/// <summary>
            /// Creates a new union with '11' possible cases and sets it to a value of the type 'K'
            /// </summary>
            /// <param name="item">Union value of the type K</param>
            public Case11(K item)
				: base() => Item = item;

			public static implicit operator K(Case11 c) => c.Item;
			public static implicit operator Case11(K i) => new Case11(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 12 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'I'
        /// </summary>
		public virtual bool IsI => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'J'
        /// </summary>
		public virtual bool IsJ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'K'
        /// </summary>
		public virtual bool IsK => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'L'
        /// </summary>
		public virtual bool IsL => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
		/// Returns the union value cast to the type 'I'
        /// </summary>
		public I AsI => As<I>();
        /// <summary>
		/// Returns the union value cast to the type 'J'
        /// </summary>
		public J AsJ => As<J>();
        /// <summary>
		/// Returns the union value cast to the type 'K'
        /// </summary>
		public K AsK => As<K>();
        /// <summary>
		/// Returns the union value cast to the type 'L'
        /// </summary>
		public L AsL => As<L>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H)) ||
			 (typeof(_) == typeof(I)) ||
			 (typeof(_) == typeof(J)) ||
			 (typeof(_) == typeof(K)) ||
			 (typeof(_) == typeof(L))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H, I, J, K, L> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H, I, J, K, L> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H, I, J, K, L> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H, I, J, K, L> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H, I, J, K, L> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H, I, J, K, L> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H, I, J, K, L> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H, I, J, K, L> u) => u.As<H>();
		public static implicit operator I(Union<A, B, C, D, E, F, G, H, I, J, K, L> u) => u.As<I>();
		public static implicit operator J(Union<A, B, C, D, E, F, G, H, I, J, K, L> u) => u.As<J>();
		public static implicit operator K(Union<A, B, C, D, E, F, G, H, I, J, K, L> u) => u.As<K>();
		public static implicit operator L(Union<A, B, C, D, E, F, G, H, I, J, K, L> u) => u.As<L>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L>(H i) => new Case8(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L>(I i) => new Case9(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L>(J i) => new Case10(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L>(K i) => new Case11(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L>(L i) => new Case12(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l) => a(Item);

			/// <summary>
            /// Creates a new union with '12' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l) => b(Item);

			/// <summary>
            /// Creates a new union with '12' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l) => c(Item);

			/// <summary>
            /// Creates a new union with '12' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l) => d(Item);

			/// <summary>
            /// Creates a new union with '12' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l) => e(Item);

			/// <summary>
            /// Creates a new union with '12' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l) => f(Item);

			/// <summary>
            /// Creates a new union with '12' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l) => g(Item);

			/// <summary>
            /// Creates a new union with '12' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l) => h(Item);

			/// <summary>
            /// Creates a new union with '12' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
        /// <summary>
        /// Union case №9 (Represents type 'I')
        /// </summary>
		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'I'
			/// </summary>
			public override bool IsI => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public I Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => i(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l) => i(Item);

			/// <summary>
            /// Creates a new union with '12' possible cases and sets it to a value of the type 'I'
            /// </summary>
            /// <param name="item">Union value of the type I</param>
            public Case9(I item)
				: base() => Item = item;

			public static implicit operator I(Case9 c) => c.Item;
			public static implicit operator Case9(I i) => new Case9(i);
		}
        /// <summary>
        /// Union case №10 (Represents type 'J')
        /// </summary>
		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'J'
			/// </summary>
			public override bool IsJ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public J Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => j(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l) => j(Item);

			/// <summary>
            /// Creates a new union with '12' possible cases and sets it to a value of the type 'J'
            /// </summary>
            /// <param name="item">Union value of the type J</param>
            public Case10(J item)
				: base() => Item = item;

			public static implicit operator J(Case10 c) => c.Item;
			public static implicit operator Case10(J i) => new Case10(i);
		}
        /// <summary>
        /// Union case №11 (Represents type 'K')
        /// </summary>
		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'K'
			/// </summary>
			public override bool IsK => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public K Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => k(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l) => k(Item);

			/// <summary>
            /// Creates a new union with '12' possible cases and sets it to a value of the type 'K'
            /// </summary>
            /// <param name="item">Union value of the type K</param>
            public Case11(K item)
				: base() => Item = item;

			public static implicit operator K(Case11 c) => c.Item;
			public static implicit operator Case11(K i) => new Case11(i);
		}
        /// <summary>
        /// Union case №12 (Represents type 'L')
        /// </summary>
		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'L'
			/// </summary>
			public override bool IsL => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public L Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l) => l(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l) => l(Item);

			/// <summary>
            /// Creates a new union with '12' possible cases and sets it to a value of the type 'L'
            /// </summary>
            /// <param name="item">Union value of the type L</param>
            public Case12(L item)
				: base() => Item = item;

			public static implicit operator L(Case12 c) => c.Item;
			public static implicit operator Case12(L i) => new Case12(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 13 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'I'
        /// </summary>
		public virtual bool IsI => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'J'
        /// </summary>
		public virtual bool IsJ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'K'
        /// </summary>
		public virtual bool IsK => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'L'
        /// </summary>
		public virtual bool IsL => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'M'
        /// </summary>
		public virtual bool IsM => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
		/// Returns the union value cast to the type 'I'
        /// </summary>
		public I AsI => As<I>();
        /// <summary>
		/// Returns the union value cast to the type 'J'
        /// </summary>
		public J AsJ => As<J>();
        /// <summary>
		/// Returns the union value cast to the type 'K'
        /// </summary>
		public K AsK => As<K>();
        /// <summary>
		/// Returns the union value cast to the type 'L'
        /// </summary>
		public L AsL => As<L>();
        /// <summary>
		/// Returns the union value cast to the type 'M'
        /// </summary>
		public M AsM => As<M>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H)) ||
			 (typeof(_) == typeof(I)) ||
			 (typeof(_) == typeof(J)) ||
			 (typeof(_) == typeof(K)) ||
			 (typeof(_) == typeof(L)) ||
			 (typeof(_) == typeof(M))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H, I, J, K, L, M> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H, I, J, K, L, M> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H, I, J, K, L, M> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H, I, J, K, L, M> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H, I, J, K, L, M> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H, I, J, K, L, M> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H, I, J, K, L, M> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H, I, J, K, L, M> u) => u.As<H>();
		public static implicit operator I(Union<A, B, C, D, E, F, G, H, I, J, K, L, M> u) => u.As<I>();
		public static implicit operator J(Union<A, B, C, D, E, F, G, H, I, J, K, L, M> u) => u.As<J>();
		public static implicit operator K(Union<A, B, C, D, E, F, G, H, I, J, K, L, M> u) => u.As<K>();
		public static implicit operator L(Union<A, B, C, D, E, F, G, H, I, J, K, L, M> u) => u.As<L>();
		public static implicit operator M(Union<A, B, C, D, E, F, G, H, I, J, K, L, M> u) => u.As<M>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M>(H i) => new Case8(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M>(I i) => new Case9(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M>(J i) => new Case10(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M>(K i) => new Case11(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M>(L i) => new Case12(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M>(M i) => new Case13(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m) => a(Item);

			/// <summary>
            /// Creates a new union with '13' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m) => b(Item);

			/// <summary>
            /// Creates a new union with '13' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m) => c(Item);

			/// <summary>
            /// Creates a new union with '13' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m) => d(Item);

			/// <summary>
            /// Creates a new union with '13' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m) => e(Item);

			/// <summary>
            /// Creates a new union with '13' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m) => f(Item);

			/// <summary>
            /// Creates a new union with '13' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m) => g(Item);

			/// <summary>
            /// Creates a new union with '13' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m) => h(Item);

			/// <summary>
            /// Creates a new union with '13' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
        /// <summary>
        /// Union case №9 (Represents type 'I')
        /// </summary>
		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'I'
			/// </summary>
			public override bool IsI => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public I Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => i(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m) => i(Item);

			/// <summary>
            /// Creates a new union with '13' possible cases and sets it to a value of the type 'I'
            /// </summary>
            /// <param name="item">Union value of the type I</param>
            public Case9(I item)
				: base() => Item = item;

			public static implicit operator I(Case9 c) => c.Item;
			public static implicit operator Case9(I i) => new Case9(i);
		}
        /// <summary>
        /// Union case №10 (Represents type 'J')
        /// </summary>
		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'J'
			/// </summary>
			public override bool IsJ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public J Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => j(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m) => j(Item);

			/// <summary>
            /// Creates a new union with '13' possible cases and sets it to a value of the type 'J'
            /// </summary>
            /// <param name="item">Union value of the type J</param>
            public Case10(J item)
				: base() => Item = item;

			public static implicit operator J(Case10 c) => c.Item;
			public static implicit operator Case10(J i) => new Case10(i);
		}
        /// <summary>
        /// Union case №11 (Represents type 'K')
        /// </summary>
		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'K'
			/// </summary>
			public override bool IsK => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public K Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => k(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m) => k(Item);

			/// <summary>
            /// Creates a new union with '13' possible cases and sets it to a value of the type 'K'
            /// </summary>
            /// <param name="item">Union value of the type K</param>
            public Case11(K item)
				: base() => Item = item;

			public static implicit operator K(Case11 c) => c.Item;
			public static implicit operator Case11(K i) => new Case11(i);
		}
        /// <summary>
        /// Union case №12 (Represents type 'L')
        /// </summary>
		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'L'
			/// </summary>
			public override bool IsL => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public L Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => l(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m) => l(Item);

			/// <summary>
            /// Creates a new union with '13' possible cases and sets it to a value of the type 'L'
            /// </summary>
            /// <param name="item">Union value of the type L</param>
            public Case12(L item)
				: base() => Item = item;

			public static implicit operator L(Case12 c) => c.Item;
			public static implicit operator Case12(L i) => new Case12(i);
		}
        /// <summary>
        /// Union case №13 (Represents type 'M')
        /// </summary>
		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'M'
			/// </summary>
			public override bool IsM => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public M Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m) => m(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m) => m(Item);

			/// <summary>
            /// Creates a new union with '13' possible cases and sets it to a value of the type 'M'
            /// </summary>
            /// <param name="item">Union value of the type M</param>
            public Case13(M item)
				: base() => Item = item;

			public static implicit operator M(Case13 c) => c.Item;
			public static implicit operator Case13(M i) => new Case13(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 14 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'I'
        /// </summary>
		public virtual bool IsI => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'J'
        /// </summary>
		public virtual bool IsJ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'K'
        /// </summary>
		public virtual bool IsK => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'L'
        /// </summary>
		public virtual bool IsL => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'M'
        /// </summary>
		public virtual bool IsM => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'N'
        /// </summary>
		public virtual bool IsN => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
		/// Returns the union value cast to the type 'I'
        /// </summary>
		public I AsI => As<I>();
        /// <summary>
		/// Returns the union value cast to the type 'J'
        /// </summary>
		public J AsJ => As<J>();
        /// <summary>
		/// Returns the union value cast to the type 'K'
        /// </summary>
		public K AsK => As<K>();
        /// <summary>
		/// Returns the union value cast to the type 'L'
        /// </summary>
		public L AsL => As<L>();
        /// <summary>
		/// Returns the union value cast to the type 'M'
        /// </summary>
		public M AsM => As<M>();
        /// <summary>
		/// Returns the union value cast to the type 'N'
        /// </summary>
		public N AsN => As<N>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H)) ||
			 (typeof(_) == typeof(I)) ||
			 (typeof(_) == typeof(J)) ||
			 (typeof(_) == typeof(K)) ||
			 (typeof(_) == typeof(L)) ||
			 (typeof(_) == typeof(M)) ||
			 (typeof(_) == typeof(N))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N> u) => u.As<H>();
		public static implicit operator I(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N> u) => u.As<I>();
		public static implicit operator J(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N> u) => u.As<J>();
		public static implicit operator K(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N> u) => u.As<K>();
		public static implicit operator L(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N> u) => u.As<L>();
		public static implicit operator M(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N> u) => u.As<M>();
		public static implicit operator N(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N> u) => u.As<N>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(H i) => new Case8(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(I i) => new Case9(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(J i) => new Case10(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(K i) => new Case11(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(L i) => new Case12(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(M i) => new Case13(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(N i) => new Case14(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n) => a(Item);

			/// <summary>
            /// Creates a new union with '14' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n) => b(Item);

			/// <summary>
            /// Creates a new union with '14' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n) => c(Item);

			/// <summary>
            /// Creates a new union with '14' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n) => d(Item);

			/// <summary>
            /// Creates a new union with '14' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n) => e(Item);

			/// <summary>
            /// Creates a new union with '14' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n) => f(Item);

			/// <summary>
            /// Creates a new union with '14' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n) => g(Item);

			/// <summary>
            /// Creates a new union with '14' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n) => h(Item);

			/// <summary>
            /// Creates a new union with '14' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
        /// <summary>
        /// Union case №9 (Represents type 'I')
        /// </summary>
		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'I'
			/// </summary>
			public override bool IsI => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public I Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => i(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n) => i(Item);

			/// <summary>
            /// Creates a new union with '14' possible cases and sets it to a value of the type 'I'
            /// </summary>
            /// <param name="item">Union value of the type I</param>
            public Case9(I item)
				: base() => Item = item;

			public static implicit operator I(Case9 c) => c.Item;
			public static implicit operator Case9(I i) => new Case9(i);
		}
        /// <summary>
        /// Union case №10 (Represents type 'J')
        /// </summary>
		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'J'
			/// </summary>
			public override bool IsJ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public J Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => j(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n) => j(Item);

			/// <summary>
            /// Creates a new union with '14' possible cases and sets it to a value of the type 'J'
            /// </summary>
            /// <param name="item">Union value of the type J</param>
            public Case10(J item)
				: base() => Item = item;

			public static implicit operator J(Case10 c) => c.Item;
			public static implicit operator Case10(J i) => new Case10(i);
		}
        /// <summary>
        /// Union case №11 (Represents type 'K')
        /// </summary>
		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'K'
			/// </summary>
			public override bool IsK => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public K Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => k(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n) => k(Item);

			/// <summary>
            /// Creates a new union with '14' possible cases and sets it to a value of the type 'K'
            /// </summary>
            /// <param name="item">Union value of the type K</param>
            public Case11(K item)
				: base() => Item = item;

			public static implicit operator K(Case11 c) => c.Item;
			public static implicit operator Case11(K i) => new Case11(i);
		}
        /// <summary>
        /// Union case №12 (Represents type 'L')
        /// </summary>
		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'L'
			/// </summary>
			public override bool IsL => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public L Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => l(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n) => l(Item);

			/// <summary>
            /// Creates a new union with '14' possible cases and sets it to a value of the type 'L'
            /// </summary>
            /// <param name="item">Union value of the type L</param>
            public Case12(L item)
				: base() => Item = item;

			public static implicit operator L(Case12 c) => c.Item;
			public static implicit operator Case12(L i) => new Case12(i);
		}
        /// <summary>
        /// Union case №13 (Represents type 'M')
        /// </summary>
		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'M'
			/// </summary>
			public override bool IsM => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public M Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => m(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n) => m(Item);

			/// <summary>
            /// Creates a new union with '14' possible cases and sets it to a value of the type 'M'
            /// </summary>
            /// <param name="item">Union value of the type M</param>
            public Case13(M item)
				: base() => Item = item;

			public static implicit operator M(Case13 c) => c.Item;
			public static implicit operator Case13(M i) => new Case13(i);
		}
        /// <summary>
        /// Union case №14 (Represents type 'N')
        /// </summary>
		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'N'
			/// </summary>
			public override bool IsN => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public N Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n) => n(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n) => n(Item);

			/// <summary>
            /// Creates a new union with '14' possible cases and sets it to a value of the type 'N'
            /// </summary>
            /// <param name="item">Union value of the type N</param>
            public Case14(N item)
				: base() => Item = item;

			public static implicit operator N(Case14 c) => c.Item;
			public static implicit operator Case14(N i) => new Case14(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 15 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'I'
        /// </summary>
		public virtual bool IsI => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'J'
        /// </summary>
		public virtual bool IsJ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'K'
        /// </summary>
		public virtual bool IsK => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'L'
        /// </summary>
		public virtual bool IsL => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'M'
        /// </summary>
		public virtual bool IsM => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'N'
        /// </summary>
		public virtual bool IsN => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'O'
        /// </summary>
		public virtual bool IsO => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
		/// Returns the union value cast to the type 'I'
        /// </summary>
		public I AsI => As<I>();
        /// <summary>
		/// Returns the union value cast to the type 'J'
        /// </summary>
		public J AsJ => As<J>();
        /// <summary>
		/// Returns the union value cast to the type 'K'
        /// </summary>
		public K AsK => As<K>();
        /// <summary>
		/// Returns the union value cast to the type 'L'
        /// </summary>
		public L AsL => As<L>();
        /// <summary>
		/// Returns the union value cast to the type 'M'
        /// </summary>
		public M AsM => As<M>();
        /// <summary>
		/// Returns the union value cast to the type 'N'
        /// </summary>
		public N AsN => As<N>();
        /// <summary>
		/// Returns the union value cast to the type 'O'
        /// </summary>
		public O AsO => As<O>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H)) ||
			 (typeof(_) == typeof(I)) ||
			 (typeof(_) == typeof(J)) ||
			 (typeof(_) == typeof(K)) ||
			 (typeof(_) == typeof(L)) ||
			 (typeof(_) == typeof(M)) ||
			 (typeof(_) == typeof(N)) ||
			 (typeof(_) == typeof(O))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> u) => u.As<H>();
		public static implicit operator I(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> u) => u.As<I>();
		public static implicit operator J(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> u) => u.As<J>();
		public static implicit operator K(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> u) => u.As<K>();
		public static implicit operator L(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> u) => u.As<L>();
		public static implicit operator M(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> u) => u.As<M>();
		public static implicit operator N(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> u) => u.As<N>();
		public static implicit operator O(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> u) => u.As<O>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(H i) => new Case8(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(I i) => new Case9(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(J i) => new Case10(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(K i) => new Case11(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(L i) => new Case12(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(M i) => new Case13(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(N i) => new Case14(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(O i) => new Case15(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o) => a(Item);

			/// <summary>
            /// Creates a new union with '15' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o) => b(Item);

			/// <summary>
            /// Creates a new union with '15' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o) => c(Item);

			/// <summary>
            /// Creates a new union with '15' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o) => d(Item);

			/// <summary>
            /// Creates a new union with '15' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o) => e(Item);

			/// <summary>
            /// Creates a new union with '15' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o) => f(Item);

			/// <summary>
            /// Creates a new union with '15' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o) => g(Item);

			/// <summary>
            /// Creates a new union with '15' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o) => h(Item);

			/// <summary>
            /// Creates a new union with '15' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
        /// <summary>
        /// Union case №9 (Represents type 'I')
        /// </summary>
		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'I'
			/// </summary>
			public override bool IsI => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public I Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => i(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o) => i(Item);

			/// <summary>
            /// Creates a new union with '15' possible cases and sets it to a value of the type 'I'
            /// </summary>
            /// <param name="item">Union value of the type I</param>
            public Case9(I item)
				: base() => Item = item;

			public static implicit operator I(Case9 c) => c.Item;
			public static implicit operator Case9(I i) => new Case9(i);
		}
        /// <summary>
        /// Union case №10 (Represents type 'J')
        /// </summary>
		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'J'
			/// </summary>
			public override bool IsJ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public J Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => j(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o) => j(Item);

			/// <summary>
            /// Creates a new union with '15' possible cases and sets it to a value of the type 'J'
            /// </summary>
            /// <param name="item">Union value of the type J</param>
            public Case10(J item)
				: base() => Item = item;

			public static implicit operator J(Case10 c) => c.Item;
			public static implicit operator Case10(J i) => new Case10(i);
		}
        /// <summary>
        /// Union case №11 (Represents type 'K')
        /// </summary>
		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'K'
			/// </summary>
			public override bool IsK => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public K Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => k(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o) => k(Item);

			/// <summary>
            /// Creates a new union with '15' possible cases and sets it to a value of the type 'K'
            /// </summary>
            /// <param name="item">Union value of the type K</param>
            public Case11(K item)
				: base() => Item = item;

			public static implicit operator K(Case11 c) => c.Item;
			public static implicit operator Case11(K i) => new Case11(i);
		}
        /// <summary>
        /// Union case №12 (Represents type 'L')
        /// </summary>
		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'L'
			/// </summary>
			public override bool IsL => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public L Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => l(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o) => l(Item);

			/// <summary>
            /// Creates a new union with '15' possible cases and sets it to a value of the type 'L'
            /// </summary>
            /// <param name="item">Union value of the type L</param>
            public Case12(L item)
				: base() => Item = item;

			public static implicit operator L(Case12 c) => c.Item;
			public static implicit operator Case12(L i) => new Case12(i);
		}
        /// <summary>
        /// Union case №13 (Represents type 'M')
        /// </summary>
		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'M'
			/// </summary>
			public override bool IsM => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public M Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => m(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o) => m(Item);

			/// <summary>
            /// Creates a new union with '15' possible cases and sets it to a value of the type 'M'
            /// </summary>
            /// <param name="item">Union value of the type M</param>
            public Case13(M item)
				: base() => Item = item;

			public static implicit operator M(Case13 c) => c.Item;
			public static implicit operator Case13(M i) => new Case13(i);
		}
        /// <summary>
        /// Union case №14 (Represents type 'N')
        /// </summary>
		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'N'
			/// </summary>
			public override bool IsN => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public N Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => n(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o) => n(Item);

			/// <summary>
            /// Creates a new union with '15' possible cases and sets it to a value of the type 'N'
            /// </summary>
            /// <param name="item">Union value of the type N</param>
            public Case14(N item)
				: base() => Item = item;

			public static implicit operator N(Case14 c) => c.Item;
			public static implicit operator Case14(N i) => new Case14(i);
		}
        /// <summary>
        /// Union case №15 (Represents type 'O')
        /// </summary>
		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'O'
			/// </summary>
			public override bool IsO => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public O Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o) => o(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o) => o(Item);

			/// <summary>
            /// Creates a new union with '15' possible cases and sets it to a value of the type 'O'
            /// </summary>
            /// <param name="item">Union value of the type O</param>
            public Case15(O item)
				: base() => Item = item;

			public static implicit operator O(Case15 c) => c.Item;
			public static implicit operator Case15(O i) => new Case15(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 16 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'I'
        /// </summary>
		public virtual bool IsI => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'J'
        /// </summary>
		public virtual bool IsJ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'K'
        /// </summary>
		public virtual bool IsK => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'L'
        /// </summary>
		public virtual bool IsL => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'M'
        /// </summary>
		public virtual bool IsM => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'N'
        /// </summary>
		public virtual bool IsN => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'O'
        /// </summary>
		public virtual bool IsO => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'P'
        /// </summary>
		public virtual bool IsP => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
		/// Returns the union value cast to the type 'I'
        /// </summary>
		public I AsI => As<I>();
        /// <summary>
		/// Returns the union value cast to the type 'J'
        /// </summary>
		public J AsJ => As<J>();
        /// <summary>
		/// Returns the union value cast to the type 'K'
        /// </summary>
		public K AsK => As<K>();
        /// <summary>
		/// Returns the union value cast to the type 'L'
        /// </summary>
		public L AsL => As<L>();
        /// <summary>
		/// Returns the union value cast to the type 'M'
        /// </summary>
		public M AsM => As<M>();
        /// <summary>
		/// Returns the union value cast to the type 'N'
        /// </summary>
		public N AsN => As<N>();
        /// <summary>
		/// Returns the union value cast to the type 'O'
        /// </summary>
		public O AsO => As<O>();
        /// <summary>
		/// Returns the union value cast to the type 'P'
        /// </summary>
		public P AsP => As<P>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H)) ||
			 (typeof(_) == typeof(I)) ||
			 (typeof(_) == typeof(J)) ||
			 (typeof(_) == typeof(K)) ||
			 (typeof(_) == typeof(L)) ||
			 (typeof(_) == typeof(M)) ||
			 (typeof(_) == typeof(N)) ||
			 (typeof(_) == typeof(O)) ||
			 (typeof(_) == typeof(P))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> u) => u.As<H>();
		public static implicit operator I(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> u) => u.As<I>();
		public static implicit operator J(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> u) => u.As<J>();
		public static implicit operator K(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> u) => u.As<K>();
		public static implicit operator L(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> u) => u.As<L>();
		public static implicit operator M(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> u) => u.As<M>();
		public static implicit operator N(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> u) => u.As<N>();
		public static implicit operator O(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> u) => u.As<O>();
		public static implicit operator P(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> u) => u.As<P>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(H i) => new Case8(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(I i) => new Case9(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(J i) => new Case10(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(K i) => new Case11(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(L i) => new Case12(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(M i) => new Case13(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(N i) => new Case14(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(O i) => new Case15(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(P i) => new Case16(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p) => a(Item);

			/// <summary>
            /// Creates a new union with '16' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p) => b(Item);

			/// <summary>
            /// Creates a new union with '16' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p) => c(Item);

			/// <summary>
            /// Creates a new union with '16' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p) => d(Item);

			/// <summary>
            /// Creates a new union with '16' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p) => e(Item);

			/// <summary>
            /// Creates a new union with '16' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p) => f(Item);

			/// <summary>
            /// Creates a new union with '16' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p) => g(Item);

			/// <summary>
            /// Creates a new union with '16' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p) => h(Item);

			/// <summary>
            /// Creates a new union with '16' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
        /// <summary>
        /// Union case №9 (Represents type 'I')
        /// </summary>
		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'I'
			/// </summary>
			public override bool IsI => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public I Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => i(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p) => i(Item);

			/// <summary>
            /// Creates a new union with '16' possible cases and sets it to a value of the type 'I'
            /// </summary>
            /// <param name="item">Union value of the type I</param>
            public Case9(I item)
				: base() => Item = item;

			public static implicit operator I(Case9 c) => c.Item;
			public static implicit operator Case9(I i) => new Case9(i);
		}
        /// <summary>
        /// Union case №10 (Represents type 'J')
        /// </summary>
		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'J'
			/// </summary>
			public override bool IsJ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public J Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => j(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p) => j(Item);

			/// <summary>
            /// Creates a new union with '16' possible cases and sets it to a value of the type 'J'
            /// </summary>
            /// <param name="item">Union value of the type J</param>
            public Case10(J item)
				: base() => Item = item;

			public static implicit operator J(Case10 c) => c.Item;
			public static implicit operator Case10(J i) => new Case10(i);
		}
        /// <summary>
        /// Union case №11 (Represents type 'K')
        /// </summary>
		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'K'
			/// </summary>
			public override bool IsK => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public K Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => k(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p) => k(Item);

			/// <summary>
            /// Creates a new union with '16' possible cases and sets it to a value of the type 'K'
            /// </summary>
            /// <param name="item">Union value of the type K</param>
            public Case11(K item)
				: base() => Item = item;

			public static implicit operator K(Case11 c) => c.Item;
			public static implicit operator Case11(K i) => new Case11(i);
		}
        /// <summary>
        /// Union case №12 (Represents type 'L')
        /// </summary>
		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'L'
			/// </summary>
			public override bool IsL => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public L Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => l(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p) => l(Item);

			/// <summary>
            /// Creates a new union with '16' possible cases and sets it to a value of the type 'L'
            /// </summary>
            /// <param name="item">Union value of the type L</param>
            public Case12(L item)
				: base() => Item = item;

			public static implicit operator L(Case12 c) => c.Item;
			public static implicit operator Case12(L i) => new Case12(i);
		}
        /// <summary>
        /// Union case №13 (Represents type 'M')
        /// </summary>
		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'M'
			/// </summary>
			public override bool IsM => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public M Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => m(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p) => m(Item);

			/// <summary>
            /// Creates a new union with '16' possible cases and sets it to a value of the type 'M'
            /// </summary>
            /// <param name="item">Union value of the type M</param>
            public Case13(M item)
				: base() => Item = item;

			public static implicit operator M(Case13 c) => c.Item;
			public static implicit operator Case13(M i) => new Case13(i);
		}
        /// <summary>
        /// Union case №14 (Represents type 'N')
        /// </summary>
		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'N'
			/// </summary>
			public override bool IsN => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public N Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => n(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p) => n(Item);

			/// <summary>
            /// Creates a new union with '16' possible cases and sets it to a value of the type 'N'
            /// </summary>
            /// <param name="item">Union value of the type N</param>
            public Case14(N item)
				: base() => Item = item;

			public static implicit operator N(Case14 c) => c.Item;
			public static implicit operator Case14(N i) => new Case14(i);
		}
        /// <summary>
        /// Union case №15 (Represents type 'O')
        /// </summary>
		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'O'
			/// </summary>
			public override bool IsO => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public O Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => o(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p) => o(Item);

			/// <summary>
            /// Creates a new union with '16' possible cases and sets it to a value of the type 'O'
            /// </summary>
            /// <param name="item">Union value of the type O</param>
            public Case15(O item)
				: base() => Item = item;

			public static implicit operator O(Case15 c) => c.Item;
			public static implicit operator Case15(O i) => new Case15(i);
		}
        /// <summary>
        /// Union case №16 (Represents type 'P')
        /// </summary>
		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'P'
			/// </summary>
			public override bool IsP => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public P Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p) => p(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p) => p(Item);

			/// <summary>
            /// Creates a new union with '16' possible cases and sets it to a value of the type 'P'
            /// </summary>
            /// <param name="item">Union value of the type P</param>
            public Case16(P item)
				: base() => Item = item;

			public static implicit operator P(Case16 c) => c.Item;
			public static implicit operator Case16(P i) => new Case16(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 17 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'I'
        /// </summary>
		public virtual bool IsI => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'J'
        /// </summary>
		public virtual bool IsJ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'K'
        /// </summary>
		public virtual bool IsK => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'L'
        /// </summary>
		public virtual bool IsL => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'M'
        /// </summary>
		public virtual bool IsM => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'N'
        /// </summary>
		public virtual bool IsN => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'O'
        /// </summary>
		public virtual bool IsO => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'P'
        /// </summary>
		public virtual bool IsP => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'Q'
        /// </summary>
		public virtual bool IsQ => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
		/// Returns the union value cast to the type 'I'
        /// </summary>
		public I AsI => As<I>();
        /// <summary>
		/// Returns the union value cast to the type 'J'
        /// </summary>
		public J AsJ => As<J>();
        /// <summary>
		/// Returns the union value cast to the type 'K'
        /// </summary>
		public K AsK => As<K>();
        /// <summary>
		/// Returns the union value cast to the type 'L'
        /// </summary>
		public L AsL => As<L>();
        /// <summary>
		/// Returns the union value cast to the type 'M'
        /// </summary>
		public M AsM => As<M>();
        /// <summary>
		/// Returns the union value cast to the type 'N'
        /// </summary>
		public N AsN => As<N>();
        /// <summary>
		/// Returns the union value cast to the type 'O'
        /// </summary>
		public O AsO => As<O>();
        /// <summary>
		/// Returns the union value cast to the type 'P'
        /// </summary>
		public P AsP => As<P>();
        /// <summary>
		/// Returns the union value cast to the type 'Q'
        /// </summary>
		public Q AsQ => As<Q>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H)) ||
			 (typeof(_) == typeof(I)) ||
			 (typeof(_) == typeof(J)) ||
			 (typeof(_) == typeof(K)) ||
			 (typeof(_) == typeof(L)) ||
			 (typeof(_) == typeof(M)) ||
			 (typeof(_) == typeof(N)) ||
			 (typeof(_) == typeof(O)) ||
			 (typeof(_) == typeof(P)) ||
			 (typeof(_) == typeof(Q))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> u) => u.As<H>();
		public static implicit operator I(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> u) => u.As<I>();
		public static implicit operator J(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> u) => u.As<J>();
		public static implicit operator K(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> u) => u.As<K>();
		public static implicit operator L(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> u) => u.As<L>();
		public static implicit operator M(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> u) => u.As<M>();
		public static implicit operator N(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> u) => u.As<N>();
		public static implicit operator O(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> u) => u.As<O>();
		public static implicit operator P(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> u) => u.As<P>();
		public static implicit operator Q(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> u) => u.As<Q>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(H i) => new Case8(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(I i) => new Case9(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(J i) => new Case10(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(K i) => new Case11(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(L i) => new Case12(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(M i) => new Case13(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(N i) => new Case14(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(O i) => new Case15(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(P i) => new Case16(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(Q i) => new Case17(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q) => a(Item);

			/// <summary>
            /// Creates a new union with '17' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q) => b(Item);

			/// <summary>
            /// Creates a new union with '17' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q) => c(Item);

			/// <summary>
            /// Creates a new union with '17' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q) => d(Item);

			/// <summary>
            /// Creates a new union with '17' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q) => e(Item);

			/// <summary>
            /// Creates a new union with '17' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q) => f(Item);

			/// <summary>
            /// Creates a new union with '17' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q) => g(Item);

			/// <summary>
            /// Creates a new union with '17' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q) => h(Item);

			/// <summary>
            /// Creates a new union with '17' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
        /// <summary>
        /// Union case №9 (Represents type 'I')
        /// </summary>
		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'I'
			/// </summary>
			public override bool IsI => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public I Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => i(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q) => i(Item);

			/// <summary>
            /// Creates a new union with '17' possible cases and sets it to a value of the type 'I'
            /// </summary>
            /// <param name="item">Union value of the type I</param>
            public Case9(I item)
				: base() => Item = item;

			public static implicit operator I(Case9 c) => c.Item;
			public static implicit operator Case9(I i) => new Case9(i);
		}
        /// <summary>
        /// Union case №10 (Represents type 'J')
        /// </summary>
		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'J'
			/// </summary>
			public override bool IsJ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public J Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => j(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q) => j(Item);

			/// <summary>
            /// Creates a new union with '17' possible cases and sets it to a value of the type 'J'
            /// </summary>
            /// <param name="item">Union value of the type J</param>
            public Case10(J item)
				: base() => Item = item;

			public static implicit operator J(Case10 c) => c.Item;
			public static implicit operator Case10(J i) => new Case10(i);
		}
        /// <summary>
        /// Union case №11 (Represents type 'K')
        /// </summary>
		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'K'
			/// </summary>
			public override bool IsK => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public K Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => k(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q) => k(Item);

			/// <summary>
            /// Creates a new union with '17' possible cases and sets it to a value of the type 'K'
            /// </summary>
            /// <param name="item">Union value of the type K</param>
            public Case11(K item)
				: base() => Item = item;

			public static implicit operator K(Case11 c) => c.Item;
			public static implicit operator Case11(K i) => new Case11(i);
		}
        /// <summary>
        /// Union case №12 (Represents type 'L')
        /// </summary>
		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'L'
			/// </summary>
			public override bool IsL => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public L Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => l(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q) => l(Item);

			/// <summary>
            /// Creates a new union with '17' possible cases and sets it to a value of the type 'L'
            /// </summary>
            /// <param name="item">Union value of the type L</param>
            public Case12(L item)
				: base() => Item = item;

			public static implicit operator L(Case12 c) => c.Item;
			public static implicit operator Case12(L i) => new Case12(i);
		}
        /// <summary>
        /// Union case №13 (Represents type 'M')
        /// </summary>
		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'M'
			/// </summary>
			public override bool IsM => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public M Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => m(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q) => m(Item);

			/// <summary>
            /// Creates a new union with '17' possible cases and sets it to a value of the type 'M'
            /// </summary>
            /// <param name="item">Union value of the type M</param>
            public Case13(M item)
				: base() => Item = item;

			public static implicit operator M(Case13 c) => c.Item;
			public static implicit operator Case13(M i) => new Case13(i);
		}
        /// <summary>
        /// Union case №14 (Represents type 'N')
        /// </summary>
		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'N'
			/// </summary>
			public override bool IsN => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public N Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => n(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q) => n(Item);

			/// <summary>
            /// Creates a new union with '17' possible cases and sets it to a value of the type 'N'
            /// </summary>
            /// <param name="item">Union value of the type N</param>
            public Case14(N item)
				: base() => Item = item;

			public static implicit operator N(Case14 c) => c.Item;
			public static implicit operator Case14(N i) => new Case14(i);
		}
        /// <summary>
        /// Union case №15 (Represents type 'O')
        /// </summary>
		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'O'
			/// </summary>
			public override bool IsO => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public O Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => o(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q) => o(Item);

			/// <summary>
            /// Creates a new union with '17' possible cases and sets it to a value of the type 'O'
            /// </summary>
            /// <param name="item">Union value of the type O</param>
            public Case15(O item)
				: base() => Item = item;

			public static implicit operator O(Case15 c) => c.Item;
			public static implicit operator Case15(O i) => new Case15(i);
		}
        /// <summary>
        /// Union case №16 (Represents type 'P')
        /// </summary>
		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'P'
			/// </summary>
			public override bool IsP => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public P Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => p(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q) => p(Item);

			/// <summary>
            /// Creates a new union with '17' possible cases and sets it to a value of the type 'P'
            /// </summary>
            /// <param name="item">Union value of the type P</param>
            public Case16(P item)
				: base() => Item = item;

			public static implicit operator P(Case16 c) => c.Item;
			public static implicit operator Case16(P i) => new Case16(i);
		}
        /// <summary>
        /// Union case №17 (Represents type 'Q')
        /// </summary>
		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'Q'
			/// </summary>
			public override bool IsQ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public Q Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q) => q(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q) => q(Item);

			/// <summary>
            /// Creates a new union with '17' possible cases and sets it to a value of the type 'Q'
            /// </summary>
            /// <param name="item">Union value of the type Q</param>
            public Case17(Q item)
				: base() => Item = item;

			public static implicit operator Q(Case17 c) => c.Item;
			public static implicit operator Case17(Q i) => new Case17(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 18 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <param name="r">A function which matches the union type 'R'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <param name="r">A function which matches the union type 'R'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'I'
        /// </summary>
		public virtual bool IsI => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'J'
        /// </summary>
		public virtual bool IsJ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'K'
        /// </summary>
		public virtual bool IsK => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'L'
        /// </summary>
		public virtual bool IsL => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'M'
        /// </summary>
		public virtual bool IsM => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'N'
        /// </summary>
		public virtual bool IsN => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'O'
        /// </summary>
		public virtual bool IsO => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'P'
        /// </summary>
		public virtual bool IsP => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'Q'
        /// </summary>
		public virtual bool IsQ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'R'
        /// </summary>
		public virtual bool IsR => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
		/// Returns the union value cast to the type 'I'
        /// </summary>
		public I AsI => As<I>();
        /// <summary>
		/// Returns the union value cast to the type 'J'
        /// </summary>
		public J AsJ => As<J>();
        /// <summary>
		/// Returns the union value cast to the type 'K'
        /// </summary>
		public K AsK => As<K>();
        /// <summary>
		/// Returns the union value cast to the type 'L'
        /// </summary>
		public L AsL => As<L>();
        /// <summary>
		/// Returns the union value cast to the type 'M'
        /// </summary>
		public M AsM => As<M>();
        /// <summary>
		/// Returns the union value cast to the type 'N'
        /// </summary>
		public N AsN => As<N>();
        /// <summary>
		/// Returns the union value cast to the type 'O'
        /// </summary>
		public O AsO => As<O>();
        /// <summary>
		/// Returns the union value cast to the type 'P'
        /// </summary>
		public P AsP => As<P>();
        /// <summary>
		/// Returns the union value cast to the type 'Q'
        /// </summary>
		public Q AsQ => As<Q>();
        /// <summary>
		/// Returns the union value cast to the type 'R'
        /// </summary>
		public R AsR => As<R>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H)) ||
			 (typeof(_) == typeof(I)) ||
			 (typeof(_) == typeof(J)) ||
			 (typeof(_) == typeof(K)) ||
			 (typeof(_) == typeof(L)) ||
			 (typeof(_) == typeof(M)) ||
			 (typeof(_) == typeof(N)) ||
			 (typeof(_) == typeof(O)) ||
			 (typeof(_) == typeof(P)) ||
			 (typeof(_) == typeof(Q)) ||
			 (typeof(_) == typeof(R))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> u) => u.As<H>();
		public static implicit operator I(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> u) => u.As<I>();
		public static implicit operator J(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> u) => u.As<J>();
		public static implicit operator K(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> u) => u.As<K>();
		public static implicit operator L(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> u) => u.As<L>();
		public static implicit operator M(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> u) => u.As<M>();
		public static implicit operator N(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> u) => u.As<N>();
		public static implicit operator O(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> u) => u.As<O>();
		public static implicit operator P(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> u) => u.As<P>();
		public static implicit operator Q(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> u) => u.As<Q>();
		public static implicit operator R(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> u) => u.As<R>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(H i) => new Case8(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(I i) => new Case9(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(J i) => new Case10(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(K i) => new Case11(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(L i) => new Case12(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(M i) => new Case13(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(N i) => new Case14(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(O i) => new Case15(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(P i) => new Case16(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(Q i) => new Case17(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(R i) => new Case18(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r) => a(Item);

			/// <summary>
            /// Creates a new union with '18' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r) => b(Item);

			/// <summary>
            /// Creates a new union with '18' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r) => c(Item);

			/// <summary>
            /// Creates a new union with '18' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r) => d(Item);

			/// <summary>
            /// Creates a new union with '18' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r) => e(Item);

			/// <summary>
            /// Creates a new union with '18' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r) => f(Item);

			/// <summary>
            /// Creates a new union with '18' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r) => g(Item);

			/// <summary>
            /// Creates a new union with '18' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r) => h(Item);

			/// <summary>
            /// Creates a new union with '18' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
        /// <summary>
        /// Union case №9 (Represents type 'I')
        /// </summary>
		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'I'
			/// </summary>
			public override bool IsI => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public I Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => i(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r) => i(Item);

			/// <summary>
            /// Creates a new union with '18' possible cases and sets it to a value of the type 'I'
            /// </summary>
            /// <param name="item">Union value of the type I</param>
            public Case9(I item)
				: base() => Item = item;

			public static implicit operator I(Case9 c) => c.Item;
			public static implicit operator Case9(I i) => new Case9(i);
		}
        /// <summary>
        /// Union case №10 (Represents type 'J')
        /// </summary>
		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'J'
			/// </summary>
			public override bool IsJ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public J Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => j(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r) => j(Item);

			/// <summary>
            /// Creates a new union with '18' possible cases and sets it to a value of the type 'J'
            /// </summary>
            /// <param name="item">Union value of the type J</param>
            public Case10(J item)
				: base() => Item = item;

			public static implicit operator J(Case10 c) => c.Item;
			public static implicit operator Case10(J i) => new Case10(i);
		}
        /// <summary>
        /// Union case №11 (Represents type 'K')
        /// </summary>
		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'K'
			/// </summary>
			public override bool IsK => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public K Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => k(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r) => k(Item);

			/// <summary>
            /// Creates a new union with '18' possible cases and sets it to a value of the type 'K'
            /// </summary>
            /// <param name="item">Union value of the type K</param>
            public Case11(K item)
				: base() => Item = item;

			public static implicit operator K(Case11 c) => c.Item;
			public static implicit operator Case11(K i) => new Case11(i);
		}
        /// <summary>
        /// Union case №12 (Represents type 'L')
        /// </summary>
		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'L'
			/// </summary>
			public override bool IsL => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public L Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => l(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r) => l(Item);

			/// <summary>
            /// Creates a new union with '18' possible cases and sets it to a value of the type 'L'
            /// </summary>
            /// <param name="item">Union value of the type L</param>
            public Case12(L item)
				: base() => Item = item;

			public static implicit operator L(Case12 c) => c.Item;
			public static implicit operator Case12(L i) => new Case12(i);
		}
        /// <summary>
        /// Union case №13 (Represents type 'M')
        /// </summary>
		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'M'
			/// </summary>
			public override bool IsM => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public M Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => m(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r) => m(Item);

			/// <summary>
            /// Creates a new union with '18' possible cases and sets it to a value of the type 'M'
            /// </summary>
            /// <param name="item">Union value of the type M</param>
            public Case13(M item)
				: base() => Item = item;

			public static implicit operator M(Case13 c) => c.Item;
			public static implicit operator Case13(M i) => new Case13(i);
		}
        /// <summary>
        /// Union case №14 (Represents type 'N')
        /// </summary>
		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'N'
			/// </summary>
			public override bool IsN => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public N Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => n(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r) => n(Item);

			/// <summary>
            /// Creates a new union with '18' possible cases and sets it to a value of the type 'N'
            /// </summary>
            /// <param name="item">Union value of the type N</param>
            public Case14(N item)
				: base() => Item = item;

			public static implicit operator N(Case14 c) => c.Item;
			public static implicit operator Case14(N i) => new Case14(i);
		}
        /// <summary>
        /// Union case №15 (Represents type 'O')
        /// </summary>
		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'O'
			/// </summary>
			public override bool IsO => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public O Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => o(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r) => o(Item);

			/// <summary>
            /// Creates a new union with '18' possible cases and sets it to a value of the type 'O'
            /// </summary>
            /// <param name="item">Union value of the type O</param>
            public Case15(O item)
				: base() => Item = item;

			public static implicit operator O(Case15 c) => c.Item;
			public static implicit operator Case15(O i) => new Case15(i);
		}
        /// <summary>
        /// Union case №16 (Represents type 'P')
        /// </summary>
		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'P'
			/// </summary>
			public override bool IsP => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public P Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => p(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r) => p(Item);

			/// <summary>
            /// Creates a new union with '18' possible cases and sets it to a value of the type 'P'
            /// </summary>
            /// <param name="item">Union value of the type P</param>
            public Case16(P item)
				: base() => Item = item;

			public static implicit operator P(Case16 c) => c.Item;
			public static implicit operator Case16(P i) => new Case16(i);
		}
        /// <summary>
        /// Union case №17 (Represents type 'Q')
        /// </summary>
		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'Q'
			/// </summary>
			public override bool IsQ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public Q Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => q(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r) => q(Item);

			/// <summary>
            /// Creates a new union with '18' possible cases and sets it to a value of the type 'Q'
            /// </summary>
            /// <param name="item">Union value of the type Q</param>
            public Case17(Q item)
				: base() => Item = item;

			public static implicit operator Q(Case17 c) => c.Item;
			public static implicit operator Case17(Q i) => new Case17(i);
		}
        /// <summary>
        /// Union case №18 (Represents type 'R')
        /// </summary>
		public sealed class Case18
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'R'
			/// </summary>
			public override bool IsR => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public R Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r) => r(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r) => r(Item);

			/// <summary>
            /// Creates a new union with '18' possible cases and sets it to a value of the type 'R'
            /// </summary>
            /// <param name="item">Union value of the type R</param>
            public Case18(R item)
				: base() => Item = item;

			public static implicit operator R(Case18 c) => c.Item;
			public static implicit operator Case18(R i) => new Case18(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 19 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <param name="r">A function which matches the union type 'R'</param>
        /// <param name="s">A function which matches the union type 'S'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <param name="r">A function which matches the union type 'R'</param>
        /// <param name="s">A function which matches the union type 'S'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'I'
        /// </summary>
		public virtual bool IsI => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'J'
        /// </summary>
		public virtual bool IsJ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'K'
        /// </summary>
		public virtual bool IsK => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'L'
        /// </summary>
		public virtual bool IsL => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'M'
        /// </summary>
		public virtual bool IsM => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'N'
        /// </summary>
		public virtual bool IsN => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'O'
        /// </summary>
		public virtual bool IsO => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'P'
        /// </summary>
		public virtual bool IsP => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'Q'
        /// </summary>
		public virtual bool IsQ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'R'
        /// </summary>
		public virtual bool IsR => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'S'
        /// </summary>
		public virtual bool IsS => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
		/// Returns the union value cast to the type 'I'
        /// </summary>
		public I AsI => As<I>();
        /// <summary>
		/// Returns the union value cast to the type 'J'
        /// </summary>
		public J AsJ => As<J>();
        /// <summary>
		/// Returns the union value cast to the type 'K'
        /// </summary>
		public K AsK => As<K>();
        /// <summary>
		/// Returns the union value cast to the type 'L'
        /// </summary>
		public L AsL => As<L>();
        /// <summary>
		/// Returns the union value cast to the type 'M'
        /// </summary>
		public M AsM => As<M>();
        /// <summary>
		/// Returns the union value cast to the type 'N'
        /// </summary>
		public N AsN => As<N>();
        /// <summary>
		/// Returns the union value cast to the type 'O'
        /// </summary>
		public O AsO => As<O>();
        /// <summary>
		/// Returns the union value cast to the type 'P'
        /// </summary>
		public P AsP => As<P>();
        /// <summary>
		/// Returns the union value cast to the type 'Q'
        /// </summary>
		public Q AsQ => As<Q>();
        /// <summary>
		/// Returns the union value cast to the type 'R'
        /// </summary>
		public R AsR => As<R>();
        /// <summary>
		/// Returns the union value cast to the type 'S'
        /// </summary>
		public S AsS => As<S>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H)) ||
			 (typeof(_) == typeof(I)) ||
			 (typeof(_) == typeof(J)) ||
			 (typeof(_) == typeof(K)) ||
			 (typeof(_) == typeof(L)) ||
			 (typeof(_) == typeof(M)) ||
			 (typeof(_) == typeof(N)) ||
			 (typeof(_) == typeof(O)) ||
			 (typeof(_) == typeof(P)) ||
			 (typeof(_) == typeof(Q)) ||
			 (typeof(_) == typeof(R)) ||
			 (typeof(_) == typeof(S))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<H>();
		public static implicit operator I(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<I>();
		public static implicit operator J(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<J>();
		public static implicit operator K(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<K>();
		public static implicit operator L(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<L>();
		public static implicit operator M(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<M>();
		public static implicit operator N(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<N>();
		public static implicit operator O(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<O>();
		public static implicit operator P(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<P>();
		public static implicit operator Q(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<Q>();
		public static implicit operator R(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<R>();
		public static implicit operator S(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> u) => u.As<S>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(H i) => new Case8(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(I i) => new Case9(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(J i) => new Case10(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(K i) => new Case11(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(L i) => new Case12(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(M i) => new Case13(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(N i) => new Case14(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(O i) => new Case15(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(P i) => new Case16(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(Q i) => new Case17(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(R i) => new Case18(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(S i) => new Case19(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => a(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => b(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => c(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => d(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => e(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => f(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => g(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => h(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
        /// <summary>
        /// Union case №9 (Represents type 'I')
        /// </summary>
		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'I'
			/// </summary>
			public override bool IsI => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public I Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => i(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => i(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'I'
            /// </summary>
            /// <param name="item">Union value of the type I</param>
            public Case9(I item)
				: base() => Item = item;

			public static implicit operator I(Case9 c) => c.Item;
			public static implicit operator Case9(I i) => new Case9(i);
		}
        /// <summary>
        /// Union case №10 (Represents type 'J')
        /// </summary>
		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'J'
			/// </summary>
			public override bool IsJ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public J Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => j(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => j(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'J'
            /// </summary>
            /// <param name="item">Union value of the type J</param>
            public Case10(J item)
				: base() => Item = item;

			public static implicit operator J(Case10 c) => c.Item;
			public static implicit operator Case10(J i) => new Case10(i);
		}
        /// <summary>
        /// Union case №11 (Represents type 'K')
        /// </summary>
		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'K'
			/// </summary>
			public override bool IsK => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public K Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => k(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => k(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'K'
            /// </summary>
            /// <param name="item">Union value of the type K</param>
            public Case11(K item)
				: base() => Item = item;

			public static implicit operator K(Case11 c) => c.Item;
			public static implicit operator Case11(K i) => new Case11(i);
		}
        /// <summary>
        /// Union case №12 (Represents type 'L')
        /// </summary>
		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'L'
			/// </summary>
			public override bool IsL => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public L Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => l(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => l(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'L'
            /// </summary>
            /// <param name="item">Union value of the type L</param>
            public Case12(L item)
				: base() => Item = item;

			public static implicit operator L(Case12 c) => c.Item;
			public static implicit operator Case12(L i) => new Case12(i);
		}
        /// <summary>
        /// Union case №13 (Represents type 'M')
        /// </summary>
		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'M'
			/// </summary>
			public override bool IsM => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public M Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => m(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => m(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'M'
            /// </summary>
            /// <param name="item">Union value of the type M</param>
            public Case13(M item)
				: base() => Item = item;

			public static implicit operator M(Case13 c) => c.Item;
			public static implicit operator Case13(M i) => new Case13(i);
		}
        /// <summary>
        /// Union case №14 (Represents type 'N')
        /// </summary>
		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'N'
			/// </summary>
			public override bool IsN => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public N Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => n(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => n(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'N'
            /// </summary>
            /// <param name="item">Union value of the type N</param>
            public Case14(N item)
				: base() => Item = item;

			public static implicit operator N(Case14 c) => c.Item;
			public static implicit operator Case14(N i) => new Case14(i);
		}
        /// <summary>
        /// Union case №15 (Represents type 'O')
        /// </summary>
		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'O'
			/// </summary>
			public override bool IsO => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public O Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => o(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => o(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'O'
            /// </summary>
            /// <param name="item">Union value of the type O</param>
            public Case15(O item)
				: base() => Item = item;

			public static implicit operator O(Case15 c) => c.Item;
			public static implicit operator Case15(O i) => new Case15(i);
		}
        /// <summary>
        /// Union case №16 (Represents type 'P')
        /// </summary>
		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'P'
			/// </summary>
			public override bool IsP => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public P Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => p(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => p(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'P'
            /// </summary>
            /// <param name="item">Union value of the type P</param>
            public Case16(P item)
				: base() => Item = item;

			public static implicit operator P(Case16 c) => c.Item;
			public static implicit operator Case16(P i) => new Case16(i);
		}
        /// <summary>
        /// Union case №17 (Represents type 'Q')
        /// </summary>
		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'Q'
			/// </summary>
			public override bool IsQ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public Q Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => q(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => q(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'Q'
            /// </summary>
            /// <param name="item">Union value of the type Q</param>
            public Case17(Q item)
				: base() => Item = item;

			public static implicit operator Q(Case17 c) => c.Item;
			public static implicit operator Case17(Q i) => new Case17(i);
		}
        /// <summary>
        /// Union case №18 (Represents type 'R')
        /// </summary>
		public sealed class Case18
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'R'
			/// </summary>
			public override bool IsR => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public R Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => r(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => r(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'R'
            /// </summary>
            /// <param name="item">Union value of the type R</param>
            public Case18(R item)
				: base() => Item = item;

			public static implicit operator R(Case18 c) => c.Item;
			public static implicit operator Case18(R i) => new Case18(i);
		}
        /// <summary>
        /// Union case №19 (Represents type 'S')
        /// </summary>
		public sealed class Case19
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'S'
			/// </summary>
			public override bool IsS => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public S Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s) => s(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s) => s(Item);

			/// <summary>
            /// Creates a new union with '19' possible cases and sets it to a value of the type 'S'
            /// </summary>
            /// <param name="item">Union value of the type S</param>
            public Case19(S item)
				: base() => Item = item;

			public static implicit operator S(Case19 c) => c.Item;
			public static implicit operator Case19(S i) => new Case19(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 20 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <param name="r">A function which matches the union type 'R'</param>
        /// <param name="s">A function which matches the union type 'S'</param>
        /// <param name="t">A function which matches the union type 'T'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <param name="r">A function which matches the union type 'R'</param>
        /// <param name="s">A function which matches the union type 'S'</param>
        /// <param name="t">A function which matches the union type 'T'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'I'
        /// </summary>
		public virtual bool IsI => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'J'
        /// </summary>
		public virtual bool IsJ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'K'
        /// </summary>
		public virtual bool IsK => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'L'
        /// </summary>
		public virtual bool IsL => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'M'
        /// </summary>
		public virtual bool IsM => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'N'
        /// </summary>
		public virtual bool IsN => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'O'
        /// </summary>
		public virtual bool IsO => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'P'
        /// </summary>
		public virtual bool IsP => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'Q'
        /// </summary>
		public virtual bool IsQ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'R'
        /// </summary>
		public virtual bool IsR => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'S'
        /// </summary>
		public virtual bool IsS => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'T'
        /// </summary>
		public virtual bool IsT => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
		/// Returns the union value cast to the type 'I'
        /// </summary>
		public I AsI => As<I>();
        /// <summary>
		/// Returns the union value cast to the type 'J'
        /// </summary>
		public J AsJ => As<J>();
        /// <summary>
		/// Returns the union value cast to the type 'K'
        /// </summary>
		public K AsK => As<K>();
        /// <summary>
		/// Returns the union value cast to the type 'L'
        /// </summary>
		public L AsL => As<L>();
        /// <summary>
		/// Returns the union value cast to the type 'M'
        /// </summary>
		public M AsM => As<M>();
        /// <summary>
		/// Returns the union value cast to the type 'N'
        /// </summary>
		public N AsN => As<N>();
        /// <summary>
		/// Returns the union value cast to the type 'O'
        /// </summary>
		public O AsO => As<O>();
        /// <summary>
		/// Returns the union value cast to the type 'P'
        /// </summary>
		public P AsP => As<P>();
        /// <summary>
		/// Returns the union value cast to the type 'Q'
        /// </summary>
		public Q AsQ => As<Q>();
        /// <summary>
		/// Returns the union value cast to the type 'R'
        /// </summary>
		public R AsR => As<R>();
        /// <summary>
		/// Returns the union value cast to the type 'S'
        /// </summary>
		public S AsS => As<S>();
        /// <summary>
		/// Returns the union value cast to the type 'T'
        /// </summary>
		public T AsT => As<T>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H)) ||
			 (typeof(_) == typeof(I)) ||
			 (typeof(_) == typeof(J)) ||
			 (typeof(_) == typeof(K)) ||
			 (typeof(_) == typeof(L)) ||
			 (typeof(_) == typeof(M)) ||
			 (typeof(_) == typeof(N)) ||
			 (typeof(_) == typeof(O)) ||
			 (typeof(_) == typeof(P)) ||
			 (typeof(_) == typeof(Q)) ||
			 (typeof(_) == typeof(R)) ||
			 (typeof(_) == typeof(S)) ||
			 (typeof(_) == typeof(T))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<H>();
		public static implicit operator I(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<I>();
		public static implicit operator J(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<J>();
		public static implicit operator K(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<K>();
		public static implicit operator L(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<L>();
		public static implicit operator M(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<M>();
		public static implicit operator N(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<N>();
		public static implicit operator O(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<O>();
		public static implicit operator P(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<P>();
		public static implicit operator Q(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<Q>();
		public static implicit operator R(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<R>();
		public static implicit operator S(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<S>();
		public static implicit operator T(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> u) => u.As<T>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(H i) => new Case8(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(I i) => new Case9(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(J i) => new Case10(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(K i) => new Case11(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(L i) => new Case12(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(M i) => new Case13(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(N i) => new Case14(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(O i) => new Case15(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(P i) => new Case16(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(Q i) => new Case17(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(R i) => new Case18(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(S i) => new Case19(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(T i) => new Case20(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => a(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => b(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => c(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => d(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => e(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => f(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => g(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => h(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
        /// <summary>
        /// Union case №9 (Represents type 'I')
        /// </summary>
		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'I'
			/// </summary>
			public override bool IsI => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public I Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => i(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => i(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'I'
            /// </summary>
            /// <param name="item">Union value of the type I</param>
            public Case9(I item)
				: base() => Item = item;

			public static implicit operator I(Case9 c) => c.Item;
			public static implicit operator Case9(I i) => new Case9(i);
		}
        /// <summary>
        /// Union case №10 (Represents type 'J')
        /// </summary>
		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'J'
			/// </summary>
			public override bool IsJ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public J Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => j(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => j(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'J'
            /// </summary>
            /// <param name="item">Union value of the type J</param>
            public Case10(J item)
				: base() => Item = item;

			public static implicit operator J(Case10 c) => c.Item;
			public static implicit operator Case10(J i) => new Case10(i);
		}
        /// <summary>
        /// Union case №11 (Represents type 'K')
        /// </summary>
		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'K'
			/// </summary>
			public override bool IsK => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public K Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => k(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => k(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'K'
            /// </summary>
            /// <param name="item">Union value of the type K</param>
            public Case11(K item)
				: base() => Item = item;

			public static implicit operator K(Case11 c) => c.Item;
			public static implicit operator Case11(K i) => new Case11(i);
		}
        /// <summary>
        /// Union case №12 (Represents type 'L')
        /// </summary>
		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'L'
			/// </summary>
			public override bool IsL => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public L Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => l(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => l(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'L'
            /// </summary>
            /// <param name="item">Union value of the type L</param>
            public Case12(L item)
				: base() => Item = item;

			public static implicit operator L(Case12 c) => c.Item;
			public static implicit operator Case12(L i) => new Case12(i);
		}
        /// <summary>
        /// Union case №13 (Represents type 'M')
        /// </summary>
		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'M'
			/// </summary>
			public override bool IsM => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public M Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => m(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => m(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'M'
            /// </summary>
            /// <param name="item">Union value of the type M</param>
            public Case13(M item)
				: base() => Item = item;

			public static implicit operator M(Case13 c) => c.Item;
			public static implicit operator Case13(M i) => new Case13(i);
		}
        /// <summary>
        /// Union case №14 (Represents type 'N')
        /// </summary>
		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'N'
			/// </summary>
			public override bool IsN => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public N Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => n(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => n(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'N'
            /// </summary>
            /// <param name="item">Union value of the type N</param>
            public Case14(N item)
				: base() => Item = item;

			public static implicit operator N(Case14 c) => c.Item;
			public static implicit operator Case14(N i) => new Case14(i);
		}
        /// <summary>
        /// Union case №15 (Represents type 'O')
        /// </summary>
		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'O'
			/// </summary>
			public override bool IsO => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public O Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => o(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => o(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'O'
            /// </summary>
            /// <param name="item">Union value of the type O</param>
            public Case15(O item)
				: base() => Item = item;

			public static implicit operator O(Case15 c) => c.Item;
			public static implicit operator Case15(O i) => new Case15(i);
		}
        /// <summary>
        /// Union case №16 (Represents type 'P')
        /// </summary>
		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'P'
			/// </summary>
			public override bool IsP => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public P Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => p(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => p(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'P'
            /// </summary>
            /// <param name="item">Union value of the type P</param>
            public Case16(P item)
				: base() => Item = item;

			public static implicit operator P(Case16 c) => c.Item;
			public static implicit operator Case16(P i) => new Case16(i);
		}
        /// <summary>
        /// Union case №17 (Represents type 'Q')
        /// </summary>
		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'Q'
			/// </summary>
			public override bool IsQ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public Q Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => q(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => q(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'Q'
            /// </summary>
            /// <param name="item">Union value of the type Q</param>
            public Case17(Q item)
				: base() => Item = item;

			public static implicit operator Q(Case17 c) => c.Item;
			public static implicit operator Case17(Q i) => new Case17(i);
		}
        /// <summary>
        /// Union case №18 (Represents type 'R')
        /// </summary>
		public sealed class Case18
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'R'
			/// </summary>
			public override bool IsR => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public R Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => r(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => r(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'R'
            /// </summary>
            /// <param name="item">Union value of the type R</param>
            public Case18(R item)
				: base() => Item = item;

			public static implicit operator R(Case18 c) => c.Item;
			public static implicit operator Case18(R i) => new Case18(i);
		}
        /// <summary>
        /// Union case №19 (Represents type 'S')
        /// </summary>
		public sealed class Case19
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'S'
			/// </summary>
			public override bool IsS => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public S Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => s(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => s(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'S'
            /// </summary>
            /// <param name="item">Union value of the type S</param>
            public Case19(S item)
				: base() => Item = item;

			public static implicit operator S(Case19 c) => c.Item;
			public static implicit operator Case19(S i) => new Case19(i);
		}
        /// <summary>
        /// Union case №20 (Represents type 'T')
        /// </summary>
		public sealed class Case20
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'T'
			/// </summary>
			public override bool IsT => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public T Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t) => t(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t) => t(Item);

			/// <summary>
            /// Creates a new union with '20' possible cases and sets it to a value of the type 'T'
            /// </summary>
            /// <param name="item">Union value of the type T</param>
            public Case20(T item)
				: base() => Item = item;

			public static implicit operator T(Case20 c) => c.Item;
			public static implicit operator Case20(T i) => new Case20(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 21 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <param name="r">A function which matches the union type 'R'</param>
        /// <param name="s">A function which matches the union type 'S'</param>
        /// <param name="t">A function which matches the union type 'T'</param>
        /// <param name="u">A function which matches the union type 'U'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <param name="r">A function which matches the union type 'R'</param>
        /// <param name="s">A function which matches the union type 'S'</param>
        /// <param name="t">A function which matches the union type 'T'</param>
        /// <param name="u">A function which matches the union type 'U'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'I'
        /// </summary>
		public virtual bool IsI => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'J'
        /// </summary>
		public virtual bool IsJ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'K'
        /// </summary>
		public virtual bool IsK => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'L'
        /// </summary>
		public virtual bool IsL => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'M'
        /// </summary>
		public virtual bool IsM => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'N'
        /// </summary>
		public virtual bool IsN => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'O'
        /// </summary>
		public virtual bool IsO => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'P'
        /// </summary>
		public virtual bool IsP => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'Q'
        /// </summary>
		public virtual bool IsQ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'R'
        /// </summary>
		public virtual bool IsR => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'S'
        /// </summary>
		public virtual bool IsS => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'T'
        /// </summary>
		public virtual bool IsT => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'U'
        /// </summary>
		public virtual bool IsU => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
		/// Returns the union value cast to the type 'I'
        /// </summary>
		public I AsI => As<I>();
        /// <summary>
		/// Returns the union value cast to the type 'J'
        /// </summary>
		public J AsJ => As<J>();
        /// <summary>
		/// Returns the union value cast to the type 'K'
        /// </summary>
		public K AsK => As<K>();
        /// <summary>
		/// Returns the union value cast to the type 'L'
        /// </summary>
		public L AsL => As<L>();
        /// <summary>
		/// Returns the union value cast to the type 'M'
        /// </summary>
		public M AsM => As<M>();
        /// <summary>
		/// Returns the union value cast to the type 'N'
        /// </summary>
		public N AsN => As<N>();
        /// <summary>
		/// Returns the union value cast to the type 'O'
        /// </summary>
		public O AsO => As<O>();
        /// <summary>
		/// Returns the union value cast to the type 'P'
        /// </summary>
		public P AsP => As<P>();
        /// <summary>
		/// Returns the union value cast to the type 'Q'
        /// </summary>
		public Q AsQ => As<Q>();
        /// <summary>
		/// Returns the union value cast to the type 'R'
        /// </summary>
		public R AsR => As<R>();
        /// <summary>
		/// Returns the union value cast to the type 'S'
        /// </summary>
		public S AsS => As<S>();
        /// <summary>
		/// Returns the union value cast to the type 'T'
        /// </summary>
		public T AsT => As<T>();
        /// <summary>
		/// Returns the union value cast to the type 'U'
        /// </summary>
		public U AsU => As<U>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H)) ||
			 (typeof(_) == typeof(I)) ||
			 (typeof(_) == typeof(J)) ||
			 (typeof(_) == typeof(K)) ||
			 (typeof(_) == typeof(L)) ||
			 (typeof(_) == typeof(M)) ||
			 (typeof(_) == typeof(N)) ||
			 (typeof(_) == typeof(O)) ||
			 (typeof(_) == typeof(P)) ||
			 (typeof(_) == typeof(Q)) ||
			 (typeof(_) == typeof(R)) ||
			 (typeof(_) == typeof(S)) ||
			 (typeof(_) == typeof(T)) ||
			 (typeof(_) == typeof(U))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<H>();
		public static implicit operator I(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<I>();
		public static implicit operator J(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<J>();
		public static implicit operator K(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<K>();
		public static implicit operator L(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<L>();
		public static implicit operator M(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<M>();
		public static implicit operator N(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<N>();
		public static implicit operator O(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<O>();
		public static implicit operator P(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<P>();
		public static implicit operator Q(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<Q>();
		public static implicit operator R(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<R>();
		public static implicit operator S(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<S>();
		public static implicit operator T(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<T>();
		public static implicit operator U(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> u) => u.As<U>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(H i) => new Case8(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(I i) => new Case9(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(J i) => new Case10(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(K i) => new Case11(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(L i) => new Case12(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(M i) => new Case13(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(N i) => new Case14(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(O i) => new Case15(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(P i) => new Case16(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(Q i) => new Case17(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(R i) => new Case18(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(S i) => new Case19(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(T i) => new Case20(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>(U i) => new Case21(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => a(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => b(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => c(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => d(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => e(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => f(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => g(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => h(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
        /// <summary>
        /// Union case №9 (Represents type 'I')
        /// </summary>
		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'I'
			/// </summary>
			public override bool IsI => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public I Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => i(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => i(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'I'
            /// </summary>
            /// <param name="item">Union value of the type I</param>
            public Case9(I item)
				: base() => Item = item;

			public static implicit operator I(Case9 c) => c.Item;
			public static implicit operator Case9(I i) => new Case9(i);
		}
        /// <summary>
        /// Union case №10 (Represents type 'J')
        /// </summary>
		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'J'
			/// </summary>
			public override bool IsJ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public J Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => j(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => j(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'J'
            /// </summary>
            /// <param name="item">Union value of the type J</param>
            public Case10(J item)
				: base() => Item = item;

			public static implicit operator J(Case10 c) => c.Item;
			public static implicit operator Case10(J i) => new Case10(i);
		}
        /// <summary>
        /// Union case №11 (Represents type 'K')
        /// </summary>
		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'K'
			/// </summary>
			public override bool IsK => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public K Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => k(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => k(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'K'
            /// </summary>
            /// <param name="item">Union value of the type K</param>
            public Case11(K item)
				: base() => Item = item;

			public static implicit operator K(Case11 c) => c.Item;
			public static implicit operator Case11(K i) => new Case11(i);
		}
        /// <summary>
        /// Union case №12 (Represents type 'L')
        /// </summary>
		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'L'
			/// </summary>
			public override bool IsL => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public L Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => l(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => l(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'L'
            /// </summary>
            /// <param name="item">Union value of the type L</param>
            public Case12(L item)
				: base() => Item = item;

			public static implicit operator L(Case12 c) => c.Item;
			public static implicit operator Case12(L i) => new Case12(i);
		}
        /// <summary>
        /// Union case №13 (Represents type 'M')
        /// </summary>
		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'M'
			/// </summary>
			public override bool IsM => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public M Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => m(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => m(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'M'
            /// </summary>
            /// <param name="item">Union value of the type M</param>
            public Case13(M item)
				: base() => Item = item;

			public static implicit operator M(Case13 c) => c.Item;
			public static implicit operator Case13(M i) => new Case13(i);
		}
        /// <summary>
        /// Union case №14 (Represents type 'N')
        /// </summary>
		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'N'
			/// </summary>
			public override bool IsN => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public N Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => n(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => n(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'N'
            /// </summary>
            /// <param name="item">Union value of the type N</param>
            public Case14(N item)
				: base() => Item = item;

			public static implicit operator N(Case14 c) => c.Item;
			public static implicit operator Case14(N i) => new Case14(i);
		}
        /// <summary>
        /// Union case №15 (Represents type 'O')
        /// </summary>
		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'O'
			/// </summary>
			public override bool IsO => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public O Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => o(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => o(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'O'
            /// </summary>
            /// <param name="item">Union value of the type O</param>
            public Case15(O item)
				: base() => Item = item;

			public static implicit operator O(Case15 c) => c.Item;
			public static implicit operator Case15(O i) => new Case15(i);
		}
        /// <summary>
        /// Union case №16 (Represents type 'P')
        /// </summary>
		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'P'
			/// </summary>
			public override bool IsP => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public P Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => p(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => p(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'P'
            /// </summary>
            /// <param name="item">Union value of the type P</param>
            public Case16(P item)
				: base() => Item = item;

			public static implicit operator P(Case16 c) => c.Item;
			public static implicit operator Case16(P i) => new Case16(i);
		}
        /// <summary>
        /// Union case №17 (Represents type 'Q')
        /// </summary>
		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'Q'
			/// </summary>
			public override bool IsQ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public Q Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => q(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => q(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'Q'
            /// </summary>
            /// <param name="item">Union value of the type Q</param>
            public Case17(Q item)
				: base() => Item = item;

			public static implicit operator Q(Case17 c) => c.Item;
			public static implicit operator Case17(Q i) => new Case17(i);
		}
        /// <summary>
        /// Union case №18 (Represents type 'R')
        /// </summary>
		public sealed class Case18
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'R'
			/// </summary>
			public override bool IsR => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public R Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => r(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => r(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'R'
            /// </summary>
            /// <param name="item">Union value of the type R</param>
            public Case18(R item)
				: base() => Item = item;

			public static implicit operator R(Case18 c) => c.Item;
			public static implicit operator Case18(R i) => new Case18(i);
		}
        /// <summary>
        /// Union case №19 (Represents type 'S')
        /// </summary>
		public sealed class Case19
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'S'
			/// </summary>
			public override bool IsS => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public S Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => s(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => s(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'S'
            /// </summary>
            /// <param name="item">Union value of the type S</param>
            public Case19(S item)
				: base() => Item = item;

			public static implicit operator S(Case19 c) => c.Item;
			public static implicit operator Case19(S i) => new Case19(i);
		}
        /// <summary>
        /// Union case №20 (Represents type 'T')
        /// </summary>
		public sealed class Case20
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'T'
			/// </summary>
			public override bool IsT => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public T Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => t(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => t(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'T'
            /// </summary>
            /// <param name="item">Union value of the type T</param>
            public Case20(T item)
				: base() => Item = item;

			public static implicit operator T(Case20 c) => c.Item;
			public static implicit operator Case20(T i) => new Case20(i);
		}
        /// <summary>
        /// Union case №21 (Represents type 'U')
        /// </summary>
		public sealed class Case21
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'U'
			/// </summary>
			public override bool IsU => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public U Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u) => u(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u) => u(Item);

			/// <summary>
            /// Creates a new union with '21' possible cases and sets it to a value of the type 'U'
            /// </summary>
            /// <param name="item">Union value of the type U</param>
            public Case21(U item)
				: base() => Item = item;

			public static implicit operator U(Case21 c) => c.Item;
			public static implicit operator Case21(U i) => new Case21(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 22 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <param name="r">A function which matches the union type 'R'</param>
        /// <param name="s">A function which matches the union type 'S'</param>
        /// <param name="t">A function which matches the union type 'T'</param>
        /// <param name="u">A function which matches the union type 'U'</param>
        /// <param name="v">A function which matches the union type 'V'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <param name="r">A function which matches the union type 'R'</param>
        /// <param name="s">A function which matches the union type 'S'</param>
        /// <param name="t">A function which matches the union type 'T'</param>
        /// <param name="u">A function which matches the union type 'U'</param>
        /// <param name="v">A function which matches the union type 'V'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'I'
        /// </summary>
		public virtual bool IsI => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'J'
        /// </summary>
		public virtual bool IsJ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'K'
        /// </summary>
		public virtual bool IsK => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'L'
        /// </summary>
		public virtual bool IsL => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'M'
        /// </summary>
		public virtual bool IsM => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'N'
        /// </summary>
		public virtual bool IsN => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'O'
        /// </summary>
		public virtual bool IsO => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'P'
        /// </summary>
		public virtual bool IsP => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'Q'
        /// </summary>
		public virtual bool IsQ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'R'
        /// </summary>
		public virtual bool IsR => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'S'
        /// </summary>
		public virtual bool IsS => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'T'
        /// </summary>
		public virtual bool IsT => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'U'
        /// </summary>
		public virtual bool IsU => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'V'
        /// </summary>
		public virtual bool IsV => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
		/// Returns the union value cast to the type 'I'
        /// </summary>
		public I AsI => As<I>();
        /// <summary>
		/// Returns the union value cast to the type 'J'
        /// </summary>
		public J AsJ => As<J>();
        /// <summary>
		/// Returns the union value cast to the type 'K'
        /// </summary>
		public K AsK => As<K>();
        /// <summary>
		/// Returns the union value cast to the type 'L'
        /// </summary>
		public L AsL => As<L>();
        /// <summary>
		/// Returns the union value cast to the type 'M'
        /// </summary>
		public M AsM => As<M>();
        /// <summary>
		/// Returns the union value cast to the type 'N'
        /// </summary>
		public N AsN => As<N>();
        /// <summary>
		/// Returns the union value cast to the type 'O'
        /// </summary>
		public O AsO => As<O>();
        /// <summary>
		/// Returns the union value cast to the type 'P'
        /// </summary>
		public P AsP => As<P>();
        /// <summary>
		/// Returns the union value cast to the type 'Q'
        /// </summary>
		public Q AsQ => As<Q>();
        /// <summary>
		/// Returns the union value cast to the type 'R'
        /// </summary>
		public R AsR => As<R>();
        /// <summary>
		/// Returns the union value cast to the type 'S'
        /// </summary>
		public S AsS => As<S>();
        /// <summary>
		/// Returns the union value cast to the type 'T'
        /// </summary>
		public T AsT => As<T>();
        /// <summary>
		/// Returns the union value cast to the type 'U'
        /// </summary>
		public U AsU => As<U>();
        /// <summary>
		/// Returns the union value cast to the type 'V'
        /// </summary>
		public V AsV => As<V>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H)) ||
			 (typeof(_) == typeof(I)) ||
			 (typeof(_) == typeof(J)) ||
			 (typeof(_) == typeof(K)) ||
			 (typeof(_) == typeof(L)) ||
			 (typeof(_) == typeof(M)) ||
			 (typeof(_) == typeof(N)) ||
			 (typeof(_) == typeof(O)) ||
			 (typeof(_) == typeof(P)) ||
			 (typeof(_) == typeof(Q)) ||
			 (typeof(_) == typeof(R)) ||
			 (typeof(_) == typeof(S)) ||
			 (typeof(_) == typeof(T)) ||
			 (typeof(_) == typeof(U)) ||
			 (typeof(_) == typeof(V))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<H>();
		public static implicit operator I(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<I>();
		public static implicit operator J(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<J>();
		public static implicit operator K(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<K>();
		public static implicit operator L(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<L>();
		public static implicit operator M(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<M>();
		public static implicit operator N(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<N>();
		public static implicit operator O(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<O>();
		public static implicit operator P(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<P>();
		public static implicit operator Q(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<Q>();
		public static implicit operator R(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<R>();
		public static implicit operator S(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<S>();
		public static implicit operator T(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<T>();
		public static implicit operator U(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<U>();
		public static implicit operator V(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> u) => u.As<V>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(H i) => new Case8(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(I i) => new Case9(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(J i) => new Case10(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(K i) => new Case11(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(L i) => new Case12(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(M i) => new Case13(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(N i) => new Case14(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(O i) => new Case15(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(P i) => new Case16(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(Q i) => new Case17(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(R i) => new Case18(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(S i) => new Case19(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(T i) => new Case20(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(U i) => new Case21(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>(V i) => new Case22(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => a(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => b(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => c(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => d(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => e(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => f(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => g(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => h(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
        /// <summary>
        /// Union case №9 (Represents type 'I')
        /// </summary>
		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'I'
			/// </summary>
			public override bool IsI => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public I Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => i(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => i(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'I'
            /// </summary>
            /// <param name="item">Union value of the type I</param>
            public Case9(I item)
				: base() => Item = item;

			public static implicit operator I(Case9 c) => c.Item;
			public static implicit operator Case9(I i) => new Case9(i);
		}
        /// <summary>
        /// Union case №10 (Represents type 'J')
        /// </summary>
		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'J'
			/// </summary>
			public override bool IsJ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public J Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => j(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => j(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'J'
            /// </summary>
            /// <param name="item">Union value of the type J</param>
            public Case10(J item)
				: base() => Item = item;

			public static implicit operator J(Case10 c) => c.Item;
			public static implicit operator Case10(J i) => new Case10(i);
		}
        /// <summary>
        /// Union case №11 (Represents type 'K')
        /// </summary>
		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'K'
			/// </summary>
			public override bool IsK => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public K Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => k(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => k(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'K'
            /// </summary>
            /// <param name="item">Union value of the type K</param>
            public Case11(K item)
				: base() => Item = item;

			public static implicit operator K(Case11 c) => c.Item;
			public static implicit operator Case11(K i) => new Case11(i);
		}
        /// <summary>
        /// Union case №12 (Represents type 'L')
        /// </summary>
		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'L'
			/// </summary>
			public override bool IsL => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public L Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => l(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => l(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'L'
            /// </summary>
            /// <param name="item">Union value of the type L</param>
            public Case12(L item)
				: base() => Item = item;

			public static implicit operator L(Case12 c) => c.Item;
			public static implicit operator Case12(L i) => new Case12(i);
		}
        /// <summary>
        /// Union case №13 (Represents type 'M')
        /// </summary>
		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'M'
			/// </summary>
			public override bool IsM => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public M Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => m(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => m(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'M'
            /// </summary>
            /// <param name="item">Union value of the type M</param>
            public Case13(M item)
				: base() => Item = item;

			public static implicit operator M(Case13 c) => c.Item;
			public static implicit operator Case13(M i) => new Case13(i);
		}
        /// <summary>
        /// Union case №14 (Represents type 'N')
        /// </summary>
		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'N'
			/// </summary>
			public override bool IsN => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public N Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => n(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => n(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'N'
            /// </summary>
            /// <param name="item">Union value of the type N</param>
            public Case14(N item)
				: base() => Item = item;

			public static implicit operator N(Case14 c) => c.Item;
			public static implicit operator Case14(N i) => new Case14(i);
		}
        /// <summary>
        /// Union case №15 (Represents type 'O')
        /// </summary>
		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'O'
			/// </summary>
			public override bool IsO => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public O Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => o(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => o(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'O'
            /// </summary>
            /// <param name="item">Union value of the type O</param>
            public Case15(O item)
				: base() => Item = item;

			public static implicit operator O(Case15 c) => c.Item;
			public static implicit operator Case15(O i) => new Case15(i);
		}
        /// <summary>
        /// Union case №16 (Represents type 'P')
        /// </summary>
		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'P'
			/// </summary>
			public override bool IsP => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public P Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => p(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => p(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'P'
            /// </summary>
            /// <param name="item">Union value of the type P</param>
            public Case16(P item)
				: base() => Item = item;

			public static implicit operator P(Case16 c) => c.Item;
			public static implicit operator Case16(P i) => new Case16(i);
		}
        /// <summary>
        /// Union case №17 (Represents type 'Q')
        /// </summary>
		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'Q'
			/// </summary>
			public override bool IsQ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public Q Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => q(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => q(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'Q'
            /// </summary>
            /// <param name="item">Union value of the type Q</param>
            public Case17(Q item)
				: base() => Item = item;

			public static implicit operator Q(Case17 c) => c.Item;
			public static implicit operator Case17(Q i) => new Case17(i);
		}
        /// <summary>
        /// Union case №18 (Represents type 'R')
        /// </summary>
		public sealed class Case18
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'R'
			/// </summary>
			public override bool IsR => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public R Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => r(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => r(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'R'
            /// </summary>
            /// <param name="item">Union value of the type R</param>
            public Case18(R item)
				: base() => Item = item;

			public static implicit operator R(Case18 c) => c.Item;
			public static implicit operator Case18(R i) => new Case18(i);
		}
        /// <summary>
        /// Union case №19 (Represents type 'S')
        /// </summary>
		public sealed class Case19
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'S'
			/// </summary>
			public override bool IsS => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public S Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => s(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => s(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'S'
            /// </summary>
            /// <param name="item">Union value of the type S</param>
            public Case19(S item)
				: base() => Item = item;

			public static implicit operator S(Case19 c) => c.Item;
			public static implicit operator Case19(S i) => new Case19(i);
		}
        /// <summary>
        /// Union case №20 (Represents type 'T')
        /// </summary>
		public sealed class Case20
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'T'
			/// </summary>
			public override bool IsT => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public T Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => t(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => t(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'T'
            /// </summary>
            /// <param name="item">Union value of the type T</param>
            public Case20(T item)
				: base() => Item = item;

			public static implicit operator T(Case20 c) => c.Item;
			public static implicit operator Case20(T i) => new Case20(i);
		}
        /// <summary>
        /// Union case №21 (Represents type 'U')
        /// </summary>
		public sealed class Case21
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'U'
			/// </summary>
			public override bool IsU => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public U Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => u(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => u(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'U'
            /// </summary>
            /// <param name="item">Union value of the type U</param>
            public Case21(U item)
				: base() => Item = item;

			public static implicit operator U(Case21 c) => c.Item;
			public static implicit operator Case21(U i) => new Case21(i);
		}
        /// <summary>
        /// Union case №22 (Represents type 'V')
        /// </summary>
		public sealed class Case22
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'V'
			/// </summary>
			public override bool IsV => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public V Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v) => v(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v) => v(Item);

			/// <summary>
            /// Creates a new union with '22' possible cases and sets it to a value of the type 'V'
            /// </summary>
            /// <param name="item">Union value of the type V</param>
            public Case22(V item)
				: base() => Item = item;

			public static implicit operator V(Case22 c) => c.Item;
			public static implicit operator Case22(V i) => new Case22(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 23 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <param name="r">A function which matches the union type 'R'</param>
        /// <param name="s">A function which matches the union type 'S'</param>
        /// <param name="t">A function which matches the union type 'T'</param>
        /// <param name="u">A function which matches the union type 'U'</param>
        /// <param name="v">A function which matches the union type 'V'</param>
        /// <param name="w">A function which matches the union type 'W'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <param name="r">A function which matches the union type 'R'</param>
        /// <param name="s">A function which matches the union type 'S'</param>
        /// <param name="t">A function which matches the union type 'T'</param>
        /// <param name="u">A function which matches the union type 'U'</param>
        /// <param name="v">A function which matches the union type 'V'</param>
        /// <param name="w">A function which matches the union type 'W'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'I'
        /// </summary>
		public virtual bool IsI => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'J'
        /// </summary>
		public virtual bool IsJ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'K'
        /// </summary>
		public virtual bool IsK => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'L'
        /// </summary>
		public virtual bool IsL => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'M'
        /// </summary>
		public virtual bool IsM => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'N'
        /// </summary>
		public virtual bool IsN => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'O'
        /// </summary>
		public virtual bool IsO => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'P'
        /// </summary>
		public virtual bool IsP => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'Q'
        /// </summary>
		public virtual bool IsQ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'R'
        /// </summary>
		public virtual bool IsR => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'S'
        /// </summary>
		public virtual bool IsS => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'T'
        /// </summary>
		public virtual bool IsT => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'U'
        /// </summary>
		public virtual bool IsU => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'V'
        /// </summary>
		public virtual bool IsV => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'W'
        /// </summary>
		public virtual bool IsW => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
		/// Returns the union value cast to the type 'I'
        /// </summary>
		public I AsI => As<I>();
        /// <summary>
		/// Returns the union value cast to the type 'J'
        /// </summary>
		public J AsJ => As<J>();
        /// <summary>
		/// Returns the union value cast to the type 'K'
        /// </summary>
		public K AsK => As<K>();
        /// <summary>
		/// Returns the union value cast to the type 'L'
        /// </summary>
		public L AsL => As<L>();
        /// <summary>
		/// Returns the union value cast to the type 'M'
        /// </summary>
		public M AsM => As<M>();
        /// <summary>
		/// Returns the union value cast to the type 'N'
        /// </summary>
		public N AsN => As<N>();
        /// <summary>
		/// Returns the union value cast to the type 'O'
        /// </summary>
		public O AsO => As<O>();
        /// <summary>
		/// Returns the union value cast to the type 'P'
        /// </summary>
		public P AsP => As<P>();
        /// <summary>
		/// Returns the union value cast to the type 'Q'
        /// </summary>
		public Q AsQ => As<Q>();
        /// <summary>
		/// Returns the union value cast to the type 'R'
        /// </summary>
		public R AsR => As<R>();
        /// <summary>
		/// Returns the union value cast to the type 'S'
        /// </summary>
		public S AsS => As<S>();
        /// <summary>
		/// Returns the union value cast to the type 'T'
        /// </summary>
		public T AsT => As<T>();
        /// <summary>
		/// Returns the union value cast to the type 'U'
        /// </summary>
		public U AsU => As<U>();
        /// <summary>
		/// Returns the union value cast to the type 'V'
        /// </summary>
		public V AsV => As<V>();
        /// <summary>
		/// Returns the union value cast to the type 'W'
        /// </summary>
		public W AsW => As<W>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H)) ||
			 (typeof(_) == typeof(I)) ||
			 (typeof(_) == typeof(J)) ||
			 (typeof(_) == typeof(K)) ||
			 (typeof(_) == typeof(L)) ||
			 (typeof(_) == typeof(M)) ||
			 (typeof(_) == typeof(N)) ||
			 (typeof(_) == typeof(O)) ||
			 (typeof(_) == typeof(P)) ||
			 (typeof(_) == typeof(Q)) ||
			 (typeof(_) == typeof(R)) ||
			 (typeof(_) == typeof(S)) ||
			 (typeof(_) == typeof(T)) ||
			 (typeof(_) == typeof(U)) ||
			 (typeof(_) == typeof(V)) ||
			 (typeof(_) == typeof(W))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<H>();
		public static implicit operator I(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<I>();
		public static implicit operator J(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<J>();
		public static implicit operator K(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<K>();
		public static implicit operator L(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<L>();
		public static implicit operator M(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<M>();
		public static implicit operator N(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<N>();
		public static implicit operator O(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<O>();
		public static implicit operator P(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<P>();
		public static implicit operator Q(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<Q>();
		public static implicit operator R(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<R>();
		public static implicit operator S(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<S>();
		public static implicit operator T(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<T>();
		public static implicit operator U(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<U>();
		public static implicit operator V(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<V>();
		public static implicit operator W(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W> u) => u.As<W>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(H i) => new Case8(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(I i) => new Case9(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(J i) => new Case10(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(K i) => new Case11(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(L i) => new Case12(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(M i) => new Case13(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(N i) => new Case14(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(O i) => new Case15(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(P i) => new Case16(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(Q i) => new Case17(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(R i) => new Case18(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(S i) => new Case19(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(T i) => new Case20(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(U i) => new Case21(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(V i) => new Case22(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>(W i) => new Case23(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => a(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => b(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => c(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => d(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => e(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => f(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => g(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => h(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
        /// <summary>
        /// Union case №9 (Represents type 'I')
        /// </summary>
		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'I'
			/// </summary>
			public override bool IsI => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public I Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => i(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => i(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'I'
            /// </summary>
            /// <param name="item">Union value of the type I</param>
            public Case9(I item)
				: base() => Item = item;

			public static implicit operator I(Case9 c) => c.Item;
			public static implicit operator Case9(I i) => new Case9(i);
		}
        /// <summary>
        /// Union case №10 (Represents type 'J')
        /// </summary>
		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'J'
			/// </summary>
			public override bool IsJ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public J Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => j(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => j(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'J'
            /// </summary>
            /// <param name="item">Union value of the type J</param>
            public Case10(J item)
				: base() => Item = item;

			public static implicit operator J(Case10 c) => c.Item;
			public static implicit operator Case10(J i) => new Case10(i);
		}
        /// <summary>
        /// Union case №11 (Represents type 'K')
        /// </summary>
		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'K'
			/// </summary>
			public override bool IsK => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public K Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => k(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => k(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'K'
            /// </summary>
            /// <param name="item">Union value of the type K</param>
            public Case11(K item)
				: base() => Item = item;

			public static implicit operator K(Case11 c) => c.Item;
			public static implicit operator Case11(K i) => new Case11(i);
		}
        /// <summary>
        /// Union case №12 (Represents type 'L')
        /// </summary>
		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'L'
			/// </summary>
			public override bool IsL => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public L Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => l(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => l(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'L'
            /// </summary>
            /// <param name="item">Union value of the type L</param>
            public Case12(L item)
				: base() => Item = item;

			public static implicit operator L(Case12 c) => c.Item;
			public static implicit operator Case12(L i) => new Case12(i);
		}
        /// <summary>
        /// Union case №13 (Represents type 'M')
        /// </summary>
		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'M'
			/// </summary>
			public override bool IsM => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public M Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => m(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => m(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'M'
            /// </summary>
            /// <param name="item">Union value of the type M</param>
            public Case13(M item)
				: base() => Item = item;

			public static implicit operator M(Case13 c) => c.Item;
			public static implicit operator Case13(M i) => new Case13(i);
		}
        /// <summary>
        /// Union case №14 (Represents type 'N')
        /// </summary>
		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'N'
			/// </summary>
			public override bool IsN => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public N Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => n(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => n(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'N'
            /// </summary>
            /// <param name="item">Union value of the type N</param>
            public Case14(N item)
				: base() => Item = item;

			public static implicit operator N(Case14 c) => c.Item;
			public static implicit operator Case14(N i) => new Case14(i);
		}
        /// <summary>
        /// Union case №15 (Represents type 'O')
        /// </summary>
		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'O'
			/// </summary>
			public override bool IsO => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public O Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => o(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => o(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'O'
            /// </summary>
            /// <param name="item">Union value of the type O</param>
            public Case15(O item)
				: base() => Item = item;

			public static implicit operator O(Case15 c) => c.Item;
			public static implicit operator Case15(O i) => new Case15(i);
		}
        /// <summary>
        /// Union case №16 (Represents type 'P')
        /// </summary>
		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'P'
			/// </summary>
			public override bool IsP => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public P Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => p(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => p(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'P'
            /// </summary>
            /// <param name="item">Union value of the type P</param>
            public Case16(P item)
				: base() => Item = item;

			public static implicit operator P(Case16 c) => c.Item;
			public static implicit operator Case16(P i) => new Case16(i);
		}
        /// <summary>
        /// Union case №17 (Represents type 'Q')
        /// </summary>
		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'Q'
			/// </summary>
			public override bool IsQ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public Q Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => q(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => q(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'Q'
            /// </summary>
            /// <param name="item">Union value of the type Q</param>
            public Case17(Q item)
				: base() => Item = item;

			public static implicit operator Q(Case17 c) => c.Item;
			public static implicit operator Case17(Q i) => new Case17(i);
		}
        /// <summary>
        /// Union case №18 (Represents type 'R')
        /// </summary>
		public sealed class Case18
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'R'
			/// </summary>
			public override bool IsR => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public R Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => r(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => r(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'R'
            /// </summary>
            /// <param name="item">Union value of the type R</param>
            public Case18(R item)
				: base() => Item = item;

			public static implicit operator R(Case18 c) => c.Item;
			public static implicit operator Case18(R i) => new Case18(i);
		}
        /// <summary>
        /// Union case №19 (Represents type 'S')
        /// </summary>
		public sealed class Case19
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'S'
			/// </summary>
			public override bool IsS => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public S Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => s(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => s(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'S'
            /// </summary>
            /// <param name="item">Union value of the type S</param>
            public Case19(S item)
				: base() => Item = item;

			public static implicit operator S(Case19 c) => c.Item;
			public static implicit operator Case19(S i) => new Case19(i);
		}
        /// <summary>
        /// Union case №20 (Represents type 'T')
        /// </summary>
		public sealed class Case20
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'T'
			/// </summary>
			public override bool IsT => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public T Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => t(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => t(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'T'
            /// </summary>
            /// <param name="item">Union value of the type T</param>
            public Case20(T item)
				: base() => Item = item;

			public static implicit operator T(Case20 c) => c.Item;
			public static implicit operator Case20(T i) => new Case20(i);
		}
        /// <summary>
        /// Union case №21 (Represents type 'U')
        /// </summary>
		public sealed class Case21
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'U'
			/// </summary>
			public override bool IsU => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public U Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => u(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => u(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'U'
            /// </summary>
            /// <param name="item">Union value of the type U</param>
            public Case21(U item)
				: base() => Item = item;

			public static implicit operator U(Case21 c) => c.Item;
			public static implicit operator Case21(U i) => new Case21(i);
		}
        /// <summary>
        /// Union case №22 (Represents type 'V')
        /// </summary>
		public sealed class Case22
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'V'
			/// </summary>
			public override bool IsV => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public V Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => v(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => v(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'V'
            /// </summary>
            /// <param name="item">Union value of the type V</param>
            public Case22(V item)
				: base() => Item = item;

			public static implicit operator V(Case22 c) => c.Item;
			public static implicit operator Case22(V i) => new Case22(i);
		}
        /// <summary>
        /// Union case №23 (Represents type 'W')
        /// </summary>
		public sealed class Case23
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'W'
			/// </summary>
			public override bool IsW => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public W Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w) => w(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w) => w(Item);

			/// <summary>
            /// Creates a new union with '23' possible cases and sets it to a value of the type 'W'
            /// </summary>
            /// <param name="item">Union value of the type W</param>
            public Case23(W item)
				: base() => Item = item;

			public static implicit operator W(Case23 c) => c.Item;
			public static implicit operator Case23(W i) => new Case23(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 24 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <param name="r">A function which matches the union type 'R'</param>
        /// <param name="s">A function which matches the union type 'S'</param>
        /// <param name="t">A function which matches the union type 'T'</param>
        /// <param name="u">A function which matches the union type 'U'</param>
        /// <param name="v">A function which matches the union type 'V'</param>
        /// <param name="w">A function which matches the union type 'W'</param>
        /// <param name="x">A function which matches the union type 'X'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <param name="r">A function which matches the union type 'R'</param>
        /// <param name="s">A function which matches the union type 'S'</param>
        /// <param name="t">A function which matches the union type 'T'</param>
        /// <param name="u">A function which matches the union type 'U'</param>
        /// <param name="v">A function which matches the union type 'V'</param>
        /// <param name="w">A function which matches the union type 'W'</param>
        /// <param name="x">A function which matches the union type 'X'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'I'
        /// </summary>
		public virtual bool IsI => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'J'
        /// </summary>
		public virtual bool IsJ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'K'
        /// </summary>
		public virtual bool IsK => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'L'
        /// </summary>
		public virtual bool IsL => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'M'
        /// </summary>
		public virtual bool IsM => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'N'
        /// </summary>
		public virtual bool IsN => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'O'
        /// </summary>
		public virtual bool IsO => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'P'
        /// </summary>
		public virtual bool IsP => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'Q'
        /// </summary>
		public virtual bool IsQ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'R'
        /// </summary>
		public virtual bool IsR => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'S'
        /// </summary>
		public virtual bool IsS => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'T'
        /// </summary>
		public virtual bool IsT => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'U'
        /// </summary>
		public virtual bool IsU => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'V'
        /// </summary>
		public virtual bool IsV => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'W'
        /// </summary>
		public virtual bool IsW => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'X'
        /// </summary>
		public virtual bool IsX => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
		/// Returns the union value cast to the type 'I'
        /// </summary>
		public I AsI => As<I>();
        /// <summary>
		/// Returns the union value cast to the type 'J'
        /// </summary>
		public J AsJ => As<J>();
        /// <summary>
		/// Returns the union value cast to the type 'K'
        /// </summary>
		public K AsK => As<K>();
        /// <summary>
		/// Returns the union value cast to the type 'L'
        /// </summary>
		public L AsL => As<L>();
        /// <summary>
		/// Returns the union value cast to the type 'M'
        /// </summary>
		public M AsM => As<M>();
        /// <summary>
		/// Returns the union value cast to the type 'N'
        /// </summary>
		public N AsN => As<N>();
        /// <summary>
		/// Returns the union value cast to the type 'O'
        /// </summary>
		public O AsO => As<O>();
        /// <summary>
		/// Returns the union value cast to the type 'P'
        /// </summary>
		public P AsP => As<P>();
        /// <summary>
		/// Returns the union value cast to the type 'Q'
        /// </summary>
		public Q AsQ => As<Q>();
        /// <summary>
		/// Returns the union value cast to the type 'R'
        /// </summary>
		public R AsR => As<R>();
        /// <summary>
		/// Returns the union value cast to the type 'S'
        /// </summary>
		public S AsS => As<S>();
        /// <summary>
		/// Returns the union value cast to the type 'T'
        /// </summary>
		public T AsT => As<T>();
        /// <summary>
		/// Returns the union value cast to the type 'U'
        /// </summary>
		public U AsU => As<U>();
        /// <summary>
		/// Returns the union value cast to the type 'V'
        /// </summary>
		public V AsV => As<V>();
        /// <summary>
		/// Returns the union value cast to the type 'W'
        /// </summary>
		public W AsW => As<W>();
        /// <summary>
		/// Returns the union value cast to the type 'X'
        /// </summary>
		public X AsX => As<X>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H)) ||
			 (typeof(_) == typeof(I)) ||
			 (typeof(_) == typeof(J)) ||
			 (typeof(_) == typeof(K)) ||
			 (typeof(_) == typeof(L)) ||
			 (typeof(_) == typeof(M)) ||
			 (typeof(_) == typeof(N)) ||
			 (typeof(_) == typeof(O)) ||
			 (typeof(_) == typeof(P)) ||
			 (typeof(_) == typeof(Q)) ||
			 (typeof(_) == typeof(R)) ||
			 (typeof(_) == typeof(S)) ||
			 (typeof(_) == typeof(T)) ||
			 (typeof(_) == typeof(U)) ||
			 (typeof(_) == typeof(V)) ||
			 (typeof(_) == typeof(W)) ||
			 (typeof(_) == typeof(X))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<H>();
		public static implicit operator I(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<I>();
		public static implicit operator J(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<J>();
		public static implicit operator K(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<K>();
		public static implicit operator L(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<L>();
		public static implicit operator M(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<M>();
		public static implicit operator N(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<N>();
		public static implicit operator O(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<O>();
		public static implicit operator P(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<P>();
		public static implicit operator Q(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<Q>();
		public static implicit operator R(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<R>();
		public static implicit operator S(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<S>();
		public static implicit operator T(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<T>();
		public static implicit operator U(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<U>();
		public static implicit operator V(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<V>();
		public static implicit operator W(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<W>();
		public static implicit operator X(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X> u) => u.As<X>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(H i) => new Case8(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(I i) => new Case9(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(J i) => new Case10(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(K i) => new Case11(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(L i) => new Case12(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(M i) => new Case13(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(N i) => new Case14(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(O i) => new Case15(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(P i) => new Case16(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(Q i) => new Case17(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(R i) => new Case18(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(S i) => new Case19(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(T i) => new Case20(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(U i) => new Case21(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(V i) => new Case22(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(W i) => new Case23(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>(X i) => new Case24(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => a(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => b(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => c(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => d(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => e(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => f(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => g(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => h(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
        /// <summary>
        /// Union case №9 (Represents type 'I')
        /// </summary>
		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'I'
			/// </summary>
			public override bool IsI => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public I Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => i(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => i(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'I'
            /// </summary>
            /// <param name="item">Union value of the type I</param>
            public Case9(I item)
				: base() => Item = item;

			public static implicit operator I(Case9 c) => c.Item;
			public static implicit operator Case9(I i) => new Case9(i);
		}
        /// <summary>
        /// Union case №10 (Represents type 'J')
        /// </summary>
		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'J'
			/// </summary>
			public override bool IsJ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public J Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => j(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => j(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'J'
            /// </summary>
            /// <param name="item">Union value of the type J</param>
            public Case10(J item)
				: base() => Item = item;

			public static implicit operator J(Case10 c) => c.Item;
			public static implicit operator Case10(J i) => new Case10(i);
		}
        /// <summary>
        /// Union case №11 (Represents type 'K')
        /// </summary>
		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'K'
			/// </summary>
			public override bool IsK => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public K Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => k(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => k(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'K'
            /// </summary>
            /// <param name="item">Union value of the type K</param>
            public Case11(K item)
				: base() => Item = item;

			public static implicit operator K(Case11 c) => c.Item;
			public static implicit operator Case11(K i) => new Case11(i);
		}
        /// <summary>
        /// Union case №12 (Represents type 'L')
        /// </summary>
		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'L'
			/// </summary>
			public override bool IsL => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public L Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => l(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => l(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'L'
            /// </summary>
            /// <param name="item">Union value of the type L</param>
            public Case12(L item)
				: base() => Item = item;

			public static implicit operator L(Case12 c) => c.Item;
			public static implicit operator Case12(L i) => new Case12(i);
		}
        /// <summary>
        /// Union case №13 (Represents type 'M')
        /// </summary>
		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'M'
			/// </summary>
			public override bool IsM => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public M Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => m(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => m(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'M'
            /// </summary>
            /// <param name="item">Union value of the type M</param>
            public Case13(M item)
				: base() => Item = item;

			public static implicit operator M(Case13 c) => c.Item;
			public static implicit operator Case13(M i) => new Case13(i);
		}
        /// <summary>
        /// Union case №14 (Represents type 'N')
        /// </summary>
		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'N'
			/// </summary>
			public override bool IsN => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public N Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => n(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => n(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'N'
            /// </summary>
            /// <param name="item">Union value of the type N</param>
            public Case14(N item)
				: base() => Item = item;

			public static implicit operator N(Case14 c) => c.Item;
			public static implicit operator Case14(N i) => new Case14(i);
		}
        /// <summary>
        /// Union case №15 (Represents type 'O')
        /// </summary>
		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'O'
			/// </summary>
			public override bool IsO => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public O Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => o(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => o(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'O'
            /// </summary>
            /// <param name="item">Union value of the type O</param>
            public Case15(O item)
				: base() => Item = item;

			public static implicit operator O(Case15 c) => c.Item;
			public static implicit operator Case15(O i) => new Case15(i);
		}
        /// <summary>
        /// Union case №16 (Represents type 'P')
        /// </summary>
		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'P'
			/// </summary>
			public override bool IsP => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public P Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => p(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => p(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'P'
            /// </summary>
            /// <param name="item">Union value of the type P</param>
            public Case16(P item)
				: base() => Item = item;

			public static implicit operator P(Case16 c) => c.Item;
			public static implicit operator Case16(P i) => new Case16(i);
		}
        /// <summary>
        /// Union case №17 (Represents type 'Q')
        /// </summary>
		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'Q'
			/// </summary>
			public override bool IsQ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public Q Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => q(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => q(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'Q'
            /// </summary>
            /// <param name="item">Union value of the type Q</param>
            public Case17(Q item)
				: base() => Item = item;

			public static implicit operator Q(Case17 c) => c.Item;
			public static implicit operator Case17(Q i) => new Case17(i);
		}
        /// <summary>
        /// Union case №18 (Represents type 'R')
        /// </summary>
		public sealed class Case18
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'R'
			/// </summary>
			public override bool IsR => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public R Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => r(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => r(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'R'
            /// </summary>
            /// <param name="item">Union value of the type R</param>
            public Case18(R item)
				: base() => Item = item;

			public static implicit operator R(Case18 c) => c.Item;
			public static implicit operator Case18(R i) => new Case18(i);
		}
        /// <summary>
        /// Union case №19 (Represents type 'S')
        /// </summary>
		public sealed class Case19
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'S'
			/// </summary>
			public override bool IsS => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public S Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => s(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => s(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'S'
            /// </summary>
            /// <param name="item">Union value of the type S</param>
            public Case19(S item)
				: base() => Item = item;

			public static implicit operator S(Case19 c) => c.Item;
			public static implicit operator Case19(S i) => new Case19(i);
		}
        /// <summary>
        /// Union case №20 (Represents type 'T')
        /// </summary>
		public sealed class Case20
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'T'
			/// </summary>
			public override bool IsT => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public T Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => t(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => t(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'T'
            /// </summary>
            /// <param name="item">Union value of the type T</param>
            public Case20(T item)
				: base() => Item = item;

			public static implicit operator T(Case20 c) => c.Item;
			public static implicit operator Case20(T i) => new Case20(i);
		}
        /// <summary>
        /// Union case №21 (Represents type 'U')
        /// </summary>
		public sealed class Case21
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'U'
			/// </summary>
			public override bool IsU => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public U Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => u(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => u(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'U'
            /// </summary>
            /// <param name="item">Union value of the type U</param>
            public Case21(U item)
				: base() => Item = item;

			public static implicit operator U(Case21 c) => c.Item;
			public static implicit operator Case21(U i) => new Case21(i);
		}
        /// <summary>
        /// Union case №22 (Represents type 'V')
        /// </summary>
		public sealed class Case22
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'V'
			/// </summary>
			public override bool IsV => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public V Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => v(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => v(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'V'
            /// </summary>
            /// <param name="item">Union value of the type V</param>
            public Case22(V item)
				: base() => Item = item;

			public static implicit operator V(Case22 c) => c.Item;
			public static implicit operator Case22(V i) => new Case22(i);
		}
        /// <summary>
        /// Union case №23 (Represents type 'W')
        /// </summary>
		public sealed class Case23
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'W'
			/// </summary>
			public override bool IsW => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public W Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => w(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => w(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'W'
            /// </summary>
            /// <param name="item">Union value of the type W</param>
            public Case23(W item)
				: base() => Item = item;

			public static implicit operator W(Case23 c) => c.Item;
			public static implicit operator Case23(W i) => new Case23(i);
		}
        /// <summary>
        /// Union case №24 (Represents type 'X')
        /// </summary>
		public sealed class Case24
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'X'
			/// </summary>
			public override bool IsX => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public X Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x) => x(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x) => x(Item);

			/// <summary>
            /// Creates a new union with '24' possible cases and sets it to a value of the type 'X'
            /// </summary>
            /// <param name="item">Union value of the type X</param>
            public Case24(X item)
				: base() => Item = item;

			public static implicit operator X(Case24 c) => c.Item;
			public static implicit operator Case24(X i) => new Case24(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 25 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <param name="r">A function which matches the union type 'R'</param>
        /// <param name="s">A function which matches the union type 'S'</param>
        /// <param name="t">A function which matches the union type 'T'</param>
        /// <param name="u">A function which matches the union type 'U'</param>
        /// <param name="v">A function which matches the union type 'V'</param>
        /// <param name="w">A function which matches the union type 'W'</param>
        /// <param name="x">A function which matches the union type 'X'</param>
        /// <param name="y">A function which matches the union type 'Y'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <param name="r">A function which matches the union type 'R'</param>
        /// <param name="s">A function which matches the union type 'S'</param>
        /// <param name="t">A function which matches the union type 'T'</param>
        /// <param name="u">A function which matches the union type 'U'</param>
        /// <param name="v">A function which matches the union type 'V'</param>
        /// <param name="w">A function which matches the union type 'W'</param>
        /// <param name="x">A function which matches the union type 'X'</param>
        /// <param name="y">A function which matches the union type 'Y'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'I'
        /// </summary>
		public virtual bool IsI => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'J'
        /// </summary>
		public virtual bool IsJ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'K'
        /// </summary>
		public virtual bool IsK => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'L'
        /// </summary>
		public virtual bool IsL => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'M'
        /// </summary>
		public virtual bool IsM => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'N'
        /// </summary>
		public virtual bool IsN => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'O'
        /// </summary>
		public virtual bool IsO => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'P'
        /// </summary>
		public virtual bool IsP => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'Q'
        /// </summary>
		public virtual bool IsQ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'R'
        /// </summary>
		public virtual bool IsR => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'S'
        /// </summary>
		public virtual bool IsS => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'T'
        /// </summary>
		public virtual bool IsT => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'U'
        /// </summary>
		public virtual bool IsU => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'V'
        /// </summary>
		public virtual bool IsV => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'W'
        /// </summary>
		public virtual bool IsW => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'X'
        /// </summary>
		public virtual bool IsX => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'Y'
        /// </summary>
		public virtual bool IsY => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
		/// Returns the union value cast to the type 'I'
        /// </summary>
		public I AsI => As<I>();
        /// <summary>
		/// Returns the union value cast to the type 'J'
        /// </summary>
		public J AsJ => As<J>();
        /// <summary>
		/// Returns the union value cast to the type 'K'
        /// </summary>
		public K AsK => As<K>();
        /// <summary>
		/// Returns the union value cast to the type 'L'
        /// </summary>
		public L AsL => As<L>();
        /// <summary>
		/// Returns the union value cast to the type 'M'
        /// </summary>
		public M AsM => As<M>();
        /// <summary>
		/// Returns the union value cast to the type 'N'
        /// </summary>
		public N AsN => As<N>();
        /// <summary>
		/// Returns the union value cast to the type 'O'
        /// </summary>
		public O AsO => As<O>();
        /// <summary>
		/// Returns the union value cast to the type 'P'
        /// </summary>
		public P AsP => As<P>();
        /// <summary>
		/// Returns the union value cast to the type 'Q'
        /// </summary>
		public Q AsQ => As<Q>();
        /// <summary>
		/// Returns the union value cast to the type 'R'
        /// </summary>
		public R AsR => As<R>();
        /// <summary>
		/// Returns the union value cast to the type 'S'
        /// </summary>
		public S AsS => As<S>();
        /// <summary>
		/// Returns the union value cast to the type 'T'
        /// </summary>
		public T AsT => As<T>();
        /// <summary>
		/// Returns the union value cast to the type 'U'
        /// </summary>
		public U AsU => As<U>();
        /// <summary>
		/// Returns the union value cast to the type 'V'
        /// </summary>
		public V AsV => As<V>();
        /// <summary>
		/// Returns the union value cast to the type 'W'
        /// </summary>
		public W AsW => As<W>();
        /// <summary>
		/// Returns the union value cast to the type 'X'
        /// </summary>
		public X AsX => As<X>();
        /// <summary>
		/// Returns the union value cast to the type 'Y'
        /// </summary>
		public Y AsY => As<Y>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H)) ||
			 (typeof(_) == typeof(I)) ||
			 (typeof(_) == typeof(J)) ||
			 (typeof(_) == typeof(K)) ||
			 (typeof(_) == typeof(L)) ||
			 (typeof(_) == typeof(M)) ||
			 (typeof(_) == typeof(N)) ||
			 (typeof(_) == typeof(O)) ||
			 (typeof(_) == typeof(P)) ||
			 (typeof(_) == typeof(Q)) ||
			 (typeof(_) == typeof(R)) ||
			 (typeof(_) == typeof(S)) ||
			 (typeof(_) == typeof(T)) ||
			 (typeof(_) == typeof(U)) ||
			 (typeof(_) == typeof(V)) ||
			 (typeof(_) == typeof(W)) ||
			 (typeof(_) == typeof(X)) ||
			 (typeof(_) == typeof(Y))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<H>();
		public static implicit operator I(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<I>();
		public static implicit operator J(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<J>();
		public static implicit operator K(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<K>();
		public static implicit operator L(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<L>();
		public static implicit operator M(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<M>();
		public static implicit operator N(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<N>();
		public static implicit operator O(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<O>();
		public static implicit operator P(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<P>();
		public static implicit operator Q(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<Q>();
		public static implicit operator R(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<R>();
		public static implicit operator S(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<S>();
		public static implicit operator T(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<T>();
		public static implicit operator U(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<U>();
		public static implicit operator V(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<V>();
		public static implicit operator W(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<W>();
		public static implicit operator X(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<X>();
		public static implicit operator Y(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y> u) => u.As<Y>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(H i) => new Case8(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(I i) => new Case9(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(J i) => new Case10(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(K i) => new Case11(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(L i) => new Case12(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(M i) => new Case13(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(N i) => new Case14(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(O i) => new Case15(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(P i) => new Case16(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(Q i) => new Case17(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(R i) => new Case18(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(S i) => new Case19(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(T i) => new Case20(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(U i) => new Case21(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(V i) => new Case22(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(W i) => new Case23(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(X i) => new Case24(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>(Y i) => new Case25(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => a(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => b(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => c(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => d(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => e(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => f(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => g(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => h(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
        /// <summary>
        /// Union case №9 (Represents type 'I')
        /// </summary>
		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'I'
			/// </summary>
			public override bool IsI => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public I Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => i(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => i(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'I'
            /// </summary>
            /// <param name="item">Union value of the type I</param>
            public Case9(I item)
				: base() => Item = item;

			public static implicit operator I(Case9 c) => c.Item;
			public static implicit operator Case9(I i) => new Case9(i);
		}
        /// <summary>
        /// Union case №10 (Represents type 'J')
        /// </summary>
		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'J'
			/// </summary>
			public override bool IsJ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public J Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => j(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => j(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'J'
            /// </summary>
            /// <param name="item">Union value of the type J</param>
            public Case10(J item)
				: base() => Item = item;

			public static implicit operator J(Case10 c) => c.Item;
			public static implicit operator Case10(J i) => new Case10(i);
		}
        /// <summary>
        /// Union case №11 (Represents type 'K')
        /// </summary>
		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'K'
			/// </summary>
			public override bool IsK => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public K Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => k(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => k(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'K'
            /// </summary>
            /// <param name="item">Union value of the type K</param>
            public Case11(K item)
				: base() => Item = item;

			public static implicit operator K(Case11 c) => c.Item;
			public static implicit operator Case11(K i) => new Case11(i);
		}
        /// <summary>
        /// Union case №12 (Represents type 'L')
        /// </summary>
		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'L'
			/// </summary>
			public override bool IsL => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public L Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => l(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => l(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'L'
            /// </summary>
            /// <param name="item">Union value of the type L</param>
            public Case12(L item)
				: base() => Item = item;

			public static implicit operator L(Case12 c) => c.Item;
			public static implicit operator Case12(L i) => new Case12(i);
		}
        /// <summary>
        /// Union case №13 (Represents type 'M')
        /// </summary>
		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'M'
			/// </summary>
			public override bool IsM => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public M Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => m(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => m(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'M'
            /// </summary>
            /// <param name="item">Union value of the type M</param>
            public Case13(M item)
				: base() => Item = item;

			public static implicit operator M(Case13 c) => c.Item;
			public static implicit operator Case13(M i) => new Case13(i);
		}
        /// <summary>
        /// Union case №14 (Represents type 'N')
        /// </summary>
		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'N'
			/// </summary>
			public override bool IsN => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public N Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => n(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => n(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'N'
            /// </summary>
            /// <param name="item">Union value of the type N</param>
            public Case14(N item)
				: base() => Item = item;

			public static implicit operator N(Case14 c) => c.Item;
			public static implicit operator Case14(N i) => new Case14(i);
		}
        /// <summary>
        /// Union case №15 (Represents type 'O')
        /// </summary>
		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'O'
			/// </summary>
			public override bool IsO => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public O Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => o(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => o(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'O'
            /// </summary>
            /// <param name="item">Union value of the type O</param>
            public Case15(O item)
				: base() => Item = item;

			public static implicit operator O(Case15 c) => c.Item;
			public static implicit operator Case15(O i) => new Case15(i);
		}
        /// <summary>
        /// Union case №16 (Represents type 'P')
        /// </summary>
		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'P'
			/// </summary>
			public override bool IsP => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public P Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => p(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => p(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'P'
            /// </summary>
            /// <param name="item">Union value of the type P</param>
            public Case16(P item)
				: base() => Item = item;

			public static implicit operator P(Case16 c) => c.Item;
			public static implicit operator Case16(P i) => new Case16(i);
		}
        /// <summary>
        /// Union case №17 (Represents type 'Q')
        /// </summary>
		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'Q'
			/// </summary>
			public override bool IsQ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public Q Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => q(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => q(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'Q'
            /// </summary>
            /// <param name="item">Union value of the type Q</param>
            public Case17(Q item)
				: base() => Item = item;

			public static implicit operator Q(Case17 c) => c.Item;
			public static implicit operator Case17(Q i) => new Case17(i);
		}
        /// <summary>
        /// Union case №18 (Represents type 'R')
        /// </summary>
		public sealed class Case18
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'R'
			/// </summary>
			public override bool IsR => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public R Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => r(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => r(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'R'
            /// </summary>
            /// <param name="item">Union value of the type R</param>
            public Case18(R item)
				: base() => Item = item;

			public static implicit operator R(Case18 c) => c.Item;
			public static implicit operator Case18(R i) => new Case18(i);
		}
        /// <summary>
        /// Union case №19 (Represents type 'S')
        /// </summary>
		public sealed class Case19
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'S'
			/// </summary>
			public override bool IsS => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public S Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => s(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => s(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'S'
            /// </summary>
            /// <param name="item">Union value of the type S</param>
            public Case19(S item)
				: base() => Item = item;

			public static implicit operator S(Case19 c) => c.Item;
			public static implicit operator Case19(S i) => new Case19(i);
		}
        /// <summary>
        /// Union case №20 (Represents type 'T')
        /// </summary>
		public sealed class Case20
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'T'
			/// </summary>
			public override bool IsT => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public T Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => t(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => t(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'T'
            /// </summary>
            /// <param name="item">Union value of the type T</param>
            public Case20(T item)
				: base() => Item = item;

			public static implicit operator T(Case20 c) => c.Item;
			public static implicit operator Case20(T i) => new Case20(i);
		}
        /// <summary>
        /// Union case №21 (Represents type 'U')
        /// </summary>
		public sealed class Case21
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'U'
			/// </summary>
			public override bool IsU => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public U Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => u(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => u(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'U'
            /// </summary>
            /// <param name="item">Union value of the type U</param>
            public Case21(U item)
				: base() => Item = item;

			public static implicit operator U(Case21 c) => c.Item;
			public static implicit operator Case21(U i) => new Case21(i);
		}
        /// <summary>
        /// Union case №22 (Represents type 'V')
        /// </summary>
		public sealed class Case22
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'V'
			/// </summary>
			public override bool IsV => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public V Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => v(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => v(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'V'
            /// </summary>
            /// <param name="item">Union value of the type V</param>
            public Case22(V item)
				: base() => Item = item;

			public static implicit operator V(Case22 c) => c.Item;
			public static implicit operator Case22(V i) => new Case22(i);
		}
        /// <summary>
        /// Union case №23 (Represents type 'W')
        /// </summary>
		public sealed class Case23
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'W'
			/// </summary>
			public override bool IsW => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public W Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => w(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => w(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'W'
            /// </summary>
            /// <param name="item">Union value of the type W</param>
            public Case23(W item)
				: base() => Item = item;

			public static implicit operator W(Case23 c) => c.Item;
			public static implicit operator Case23(W i) => new Case23(i);
		}
        /// <summary>
        /// Union case №24 (Represents type 'X')
        /// </summary>
		public sealed class Case24
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'X'
			/// </summary>
			public override bool IsX => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public X Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => x(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => x(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'X'
            /// </summary>
            /// <param name="item">Union value of the type X</param>
            public Case24(X item)
				: base() => Item = item;

			public static implicit operator X(Case24 c) => c.Item;
			public static implicit operator Case24(X i) => new Case24(i);
		}
        /// <summary>
        /// Union case №25 (Represents type 'Y')
        /// </summary>
		public sealed class Case25
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'Y'
			/// </summary>
			public override bool IsY => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public Y Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y) => y(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y) => y(Item);

			/// <summary>
            /// Creates a new union with '25' possible cases and sets it to a value of the type 'Y'
            /// </summary>
            /// <param name="item">Union value of the type Y</param>
            public Case25(Y item)
				: base() => Item = item;

			public static implicit operator Y(Case25 c) => c.Item;
			public static implicit operator Case25(Y i) => new Case25(i);
		}
	}

	/// <summary>
    /// A generic
#if UNSAFE
    /// type-unsafe
#else
    /// type-safe
#endif
    /// discriminated union with 26 different type cases
    /// </summary>
	public abstract class Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
#if UNSAFE
        : IUnsafeUnion
#endif
    {
        /// <summary>
        /// Matches the current union value with the given functions and executes the matching function.
        /// </summary>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <param name="r">A function which matches the union type 'R'</param>
        /// <param name="s">A function which matches the union type 'S'</param>
        /// <param name="t">A function which matches the union type 'T'</param>
        /// <param name="u">A function which matches the union type 'U'</param>
        /// <param name="v">A function which matches the union type 'V'</param>
        /// <param name="w">A function which matches the union type 'W'</param>
        /// <param name="x">A function which matches the union type 'X'</param>
        /// <param name="y">A function which matches the union type 'Y'</param>
        /// <param name="z">A function which matches the union type 'Z'</param>
        public abstract void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z);
        /// <summary>
        /// Matches the current union value with the given functions and returns the common return value of the function.
        /// </summary>
        /// <typeparam name="_">Common return type</typeparam>
        /// <param name="a">A function which matches the union type 'A'</param>
        /// <param name="b">A function which matches the union type 'B'</param>
        /// <param name="c">A function which matches the union type 'C'</param>
        /// <param name="d">A function which matches the union type 'D'</param>
        /// <param name="e">A function which matches the union type 'E'</param>
        /// <param name="f">A function which matches the union type 'F'</param>
        /// <param name="g">A function which matches the union type 'G'</param>
        /// <param name="h">A function which matches the union type 'H'</param>
        /// <param name="i">A function which matches the union type 'I'</param>
        /// <param name="j">A function which matches the union type 'J'</param>
        /// <param name="k">A function which matches the union type 'K'</param>
        /// <param name="l">A function which matches the union type 'L'</param>
        /// <param name="m">A function which matches the union type 'M'</param>
        /// <param name="n">A function which matches the union type 'N'</param>
        /// <param name="o">A function which matches the union type 'O'</param>
        /// <param name="p">A function which matches the union type 'P'</param>
        /// <param name="q">A function which matches the union type 'Q'</param>
        /// <param name="r">A function which matches the union type 'R'</param>
        /// <param name="s">A function which matches the union type 'S'</param>
        /// <param name="t">A function which matches the union type 'T'</param>
        /// <param name="u">A function which matches the union type 'U'</param>
        /// <param name="v">A function which matches the union type 'V'</param>
        /// <param name="w">A function which matches the union type 'W'</param>
        /// <param name="x">A function which matches the union type 'X'</param>
        /// <param name="y">A function which matches the union type 'Y'</param>
        /// <param name="z">A function which matches the union type 'Z'</param>
        /// <returns>Match result</returns>
        public abstract _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z);
#if UNSAFE
        /// <summary>
        /// Returns, whether the current union instance is from the type 'A'
        /// </summary>
		public virtual bool IsA => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'B'
        /// </summary>
		public virtual bool IsB => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'C'
        /// </summary>
		public virtual bool IsC => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'D'
        /// </summary>
		public virtual bool IsD => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'E'
        /// </summary>
		public virtual bool IsE => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'F'
        /// </summary>
		public virtual bool IsF => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'G'
        /// </summary>
		public virtual bool IsG => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'H'
        /// </summary>
		public virtual bool IsH => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'I'
        /// </summary>
		public virtual bool IsI => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'J'
        /// </summary>
		public virtual bool IsJ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'K'
        /// </summary>
		public virtual bool IsK => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'L'
        /// </summary>
		public virtual bool IsL => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'M'
        /// </summary>
		public virtual bool IsM => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'N'
        /// </summary>
		public virtual bool IsN => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'O'
        /// </summary>
		public virtual bool IsO => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'P'
        /// </summary>
		public virtual bool IsP => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'Q'
        /// </summary>
		public virtual bool IsQ => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'R'
        /// </summary>
		public virtual bool IsR => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'S'
        /// </summary>
		public virtual bool IsS => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'T'
        /// </summary>
		public virtual bool IsT => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'U'
        /// </summary>
		public virtual bool IsU => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'V'
        /// </summary>
		public virtual bool IsV => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'W'
        /// </summary>
		public virtual bool IsW => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'X'
        /// </summary>
		public virtual bool IsX => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'Y'
        /// </summary>
		public virtual bool IsY => false;
        /// <summary>
        /// Returns, whether the current union instance is from the type 'Z'
        /// </summary>
		public virtual bool IsZ => false;
        /// <summary>
		/// Returns the union value cast to the type 'A'
        /// </summary>
		public A AsA => As<A>();
        /// <summary>
		/// Returns the union value cast to the type 'B'
        /// </summary>
		public B AsB => As<B>();
        /// <summary>
		/// Returns the union value cast to the type 'C'
        /// </summary>
		public C AsC => As<C>();
        /// <summary>
		/// Returns the union value cast to the type 'D'
        /// </summary>
		public D AsD => As<D>();
        /// <summary>
		/// Returns the union value cast to the type 'E'
        /// </summary>
		public E AsE => As<E>();
        /// <summary>
		/// Returns the union value cast to the type 'F'
        /// </summary>
		public F AsF => As<F>();
        /// <summary>
		/// Returns the union value cast to the type 'G'
        /// </summary>
		public G AsG => As<G>();
        /// <summary>
		/// Returns the union value cast to the type 'H'
        /// </summary>
		public H AsH => As<H>();
        /// <summary>
		/// Returns the union value cast to the type 'I'
        /// </summary>
		public I AsI => As<I>();
        /// <summary>
		/// Returns the union value cast to the type 'J'
        /// </summary>
		public J AsJ => As<J>();
        /// <summary>
		/// Returns the union value cast to the type 'K'
        /// </summary>
		public K AsK => As<K>();
        /// <summary>
		/// Returns the union value cast to the type 'L'
        /// </summary>
		public L AsL => As<L>();
        /// <summary>
		/// Returns the union value cast to the type 'M'
        /// </summary>
		public M AsM => As<M>();
        /// <summary>
		/// Returns the union value cast to the type 'N'
        /// </summary>
		public N AsN => As<N>();
        /// <summary>
		/// Returns the union value cast to the type 'O'
        /// </summary>
		public O AsO => As<O>();
        /// <summary>
		/// Returns the union value cast to the type 'P'
        /// </summary>
		public P AsP => As<P>();
        /// <summary>
		/// Returns the union value cast to the type 'Q'
        /// </summary>
		public Q AsQ => As<Q>();
        /// <summary>
		/// Returns the union value cast to the type 'R'
        /// </summary>
		public R AsR => As<R>();
        /// <summary>
		/// Returns the union value cast to the type 'S'
        /// </summary>
		public S AsS => As<S>();
        /// <summary>
		/// Returns the union value cast to the type 'T'
        /// </summary>
		public T AsT => As<T>();
        /// <summary>
		/// Returns the union value cast to the type 'U'
        /// </summary>
		public U AsU => As<U>();
        /// <summary>
		/// Returns the union value cast to the type 'V'
        /// </summary>
		public V AsV => As<V>();
        /// <summary>
		/// Returns the union value cast to the type 'W'
        /// </summary>
		public W AsW => As<W>();
        /// <summary>
		/// Returns the union value cast to the type 'X'
        /// </summary>
		public X AsX => As<X>();
        /// <summary>
		/// Returns the union value cast to the type 'Y'
        /// </summary>
		public Y AsY => As<Y>();
        /// <summary>
		/// Returns the union value cast to the type 'Z'
        /// </summary>
		public Z AsZ => As<Z>();
        /// <summary>
        /// The union's type-unsafe item
        /// </summary>
		public abstract object UnsafeItem { get; }
		/// <summary>
		/// Returns whether the union contains a value of the given generic type
		/// </summary>
		public bool Is<_>() => typeof(_) == UnsafeItem?.GetType();
		/// <summary>
		/// Returns the union value cast to the given generic type.
		/// </summary>
		public _ As<_>() =>
			((typeof(_) == typeof(A)) ||
			 (typeof(_) == typeof(B)) ||
			 (typeof(_) == typeof(C)) ||
			 (typeof(_) == typeof(D)) ||
			 (typeof(_) == typeof(E)) ||
			 (typeof(_) == typeof(F)) ||
			 (typeof(_) == typeof(G)) ||
			 (typeof(_) == typeof(H)) ||
			 (typeof(_) == typeof(I)) ||
			 (typeof(_) == typeof(J)) ||
			 (typeof(_) == typeof(K)) ||
			 (typeof(_) == typeof(L)) ||
			 (typeof(_) == typeof(M)) ||
			 (typeof(_) == typeof(N)) ||
			 (typeof(_) == typeof(O)) ||
			 (typeof(_) == typeof(P)) ||
			 (typeof(_) == typeof(Q)) ||
			 (typeof(_) == typeof(R)) ||
			 (typeof(_) == typeof(S)) ||
			 (typeof(_) == typeof(T)) ||
			 (typeof(_) == typeof(U)) ||
			 (typeof(_) == typeof(V)) ||
			 (typeof(_) == typeof(W)) ||
			 (typeof(_) == typeof(X)) ||
			 (typeof(_) == typeof(Y)) ||
			 (typeof(_) == typeof(Z))) ? (_)UnsafeItem :
#if SILENT
            default(_);
#else
            throw new InvalidCastException($"The discriminated union cannot be converted to a value of the type '{typeof(_)}'.");
#endif
#endif
		// prevent inheritance by external classes
		private Union() { }

#if UNSAFE
		public static implicit operator A(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<A>();
		public static implicit operator B(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<B>();
		public static implicit operator C(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<C>();
		public static implicit operator D(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<D>();
		public static implicit operator E(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<E>();
		public static implicit operator F(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<F>();
		public static implicit operator G(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<G>();
		public static implicit operator H(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<H>();
		public static implicit operator I(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<I>();
		public static implicit operator J(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<J>();
		public static implicit operator K(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<K>();
		public static implicit operator L(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<L>();
		public static implicit operator M(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<M>();
		public static implicit operator N(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<N>();
		public static implicit operator O(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<O>();
		public static implicit operator P(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<P>();
		public static implicit operator Q(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<Q>();
		public static implicit operator R(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<R>();
		public static implicit operator S(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<S>();
		public static implicit operator T(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<T>();
		public static implicit operator U(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<U>();
		public static implicit operator V(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<V>();
		public static implicit operator W(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<W>();
		public static implicit operator X(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<X>();
		public static implicit operator Y(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<Y>();
		public static implicit operator Z(Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z> u) => u.As<Z>();
#endif
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(A i) => new Case1(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(B i) => new Case2(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(C i) => new Case3(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(D i) => new Case4(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(E i) => new Case5(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(F i) => new Case6(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(G i) => new Case7(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(H i) => new Case8(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(I i) => new Case9(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(J i) => new Case10(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(K i) => new Case11(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(L i) => new Case12(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(M i) => new Case13(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(N i) => new Case14(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(O i) => new Case15(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(P i) => new Case16(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(Q i) => new Case17(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(R i) => new Case18(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(S i) => new Case19(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(T i) => new Case20(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(U i) => new Case21(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(V i) => new Case22(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(W i) => new Case23(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(X i) => new Case24(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(Y i) => new Case25(i);
		public static implicit operator Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>(Z i) => new Case26(i);

        /// <summary>
        /// Union case №1 (Represents type 'A')
        /// </summary>
		public sealed class Case1
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'A'
			/// </summary>
			public override bool IsA => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public A Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => a(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => a(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'A'
            /// </summary>
            /// <param name="item">Union value of the type A</param>
            public Case1(A item)
				: base() => Item = item;

			public static implicit operator A(Case1 c) => c.Item;
			public static implicit operator Case1(A i) => new Case1(i);
		}
        /// <summary>
        /// Union case №2 (Represents type 'B')
        /// </summary>
		public sealed class Case2
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'B'
			/// </summary>
			public override bool IsB => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public B Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => b(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => b(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'B'
            /// </summary>
            /// <param name="item">Union value of the type B</param>
            public Case2(B item)
				: base() => Item = item;

			public static implicit operator B(Case2 c) => c.Item;
			public static implicit operator Case2(B i) => new Case2(i);
		}
        /// <summary>
        /// Union case №3 (Represents type 'C')
        /// </summary>
		public sealed class Case3
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'C'
			/// </summary>
			public override bool IsC => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public C Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => c(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => c(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'C'
            /// </summary>
            /// <param name="item">Union value of the type C</param>
            public Case3(C item)
				: base() => Item = item;

			public static implicit operator C(Case3 c) => c.Item;
			public static implicit operator Case3(C i) => new Case3(i);
		}
        /// <summary>
        /// Union case №4 (Represents type 'D')
        /// </summary>
		public sealed class Case4
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'D'
			/// </summary>
			public override bool IsD => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public D Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => d(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => d(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'D'
            /// </summary>
            /// <param name="item">Union value of the type D</param>
            public Case4(D item)
				: base() => Item = item;

			public static implicit operator D(Case4 c) => c.Item;
			public static implicit operator Case4(D i) => new Case4(i);
		}
        /// <summary>
        /// Union case №5 (Represents type 'E')
        /// </summary>
		public sealed class Case5
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'E'
			/// </summary>
			public override bool IsE => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public E Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => e(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => e(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'E'
            /// </summary>
            /// <param name="item">Union value of the type E</param>
            public Case5(E item)
				: base() => Item = item;

			public static implicit operator E(Case5 c) => c.Item;
			public static implicit operator Case5(E i) => new Case5(i);
		}
        /// <summary>
        /// Union case №6 (Represents type 'F')
        /// </summary>
		public sealed class Case6
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'F'
			/// </summary>
			public override bool IsF => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public F Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => f(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => f(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'F'
            /// </summary>
            /// <param name="item">Union value of the type F</param>
            public Case6(F item)
				: base() => Item = item;

			public static implicit operator F(Case6 c) => c.Item;
			public static implicit operator Case6(F i) => new Case6(i);
		}
        /// <summary>
        /// Union case №7 (Represents type 'G')
        /// </summary>
		public sealed class Case7
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'G'
			/// </summary>
			public override bool IsG => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public G Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => g(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => g(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'G'
            /// </summary>
            /// <param name="item">Union value of the type G</param>
            public Case7(G item)
				: base() => Item = item;

			public static implicit operator G(Case7 c) => c.Item;
			public static implicit operator Case7(G i) => new Case7(i);
		}
        /// <summary>
        /// Union case №8 (Represents type 'H')
        /// </summary>
		public sealed class Case8
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'H'
			/// </summary>
			public override bool IsH => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public H Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => h(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => h(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'H'
            /// </summary>
            /// <param name="item">Union value of the type H</param>
            public Case8(H item)
				: base() => Item = item;

			public static implicit operator H(Case8 c) => c.Item;
			public static implicit operator Case8(H i) => new Case8(i);
		}
        /// <summary>
        /// Union case №9 (Represents type 'I')
        /// </summary>
		public sealed class Case9
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'I'
			/// </summary>
			public override bool IsI => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public I Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => i(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => i(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'I'
            /// </summary>
            /// <param name="item">Union value of the type I</param>
            public Case9(I item)
				: base() => Item = item;

			public static implicit operator I(Case9 c) => c.Item;
			public static implicit operator Case9(I i) => new Case9(i);
		}
        /// <summary>
        /// Union case №10 (Represents type 'J')
        /// </summary>
		public sealed class Case10
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'J'
			/// </summary>
			public override bool IsJ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public J Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => j(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => j(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'J'
            /// </summary>
            /// <param name="item">Union value of the type J</param>
            public Case10(J item)
				: base() => Item = item;

			public static implicit operator J(Case10 c) => c.Item;
			public static implicit operator Case10(J i) => new Case10(i);
		}
        /// <summary>
        /// Union case №11 (Represents type 'K')
        /// </summary>
		public sealed class Case11
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'K'
			/// </summary>
			public override bool IsK => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public K Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => k(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => k(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'K'
            /// </summary>
            /// <param name="item">Union value of the type K</param>
            public Case11(K item)
				: base() => Item = item;

			public static implicit operator K(Case11 c) => c.Item;
			public static implicit operator Case11(K i) => new Case11(i);
		}
        /// <summary>
        /// Union case №12 (Represents type 'L')
        /// </summary>
		public sealed class Case12
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'L'
			/// </summary>
			public override bool IsL => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public L Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => l(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => l(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'L'
            /// </summary>
            /// <param name="item">Union value of the type L</param>
            public Case12(L item)
				: base() => Item = item;

			public static implicit operator L(Case12 c) => c.Item;
			public static implicit operator Case12(L i) => new Case12(i);
		}
        /// <summary>
        /// Union case №13 (Represents type 'M')
        /// </summary>
		public sealed class Case13
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'M'
			/// </summary>
			public override bool IsM => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public M Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => m(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => m(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'M'
            /// </summary>
            /// <param name="item">Union value of the type M</param>
            public Case13(M item)
				: base() => Item = item;

			public static implicit operator M(Case13 c) => c.Item;
			public static implicit operator Case13(M i) => new Case13(i);
		}
        /// <summary>
        /// Union case №14 (Represents type 'N')
        /// </summary>
		public sealed class Case14
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'N'
			/// </summary>
			public override bool IsN => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public N Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => n(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => n(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'N'
            /// </summary>
            /// <param name="item">Union value of the type N</param>
            public Case14(N item)
				: base() => Item = item;

			public static implicit operator N(Case14 c) => c.Item;
			public static implicit operator Case14(N i) => new Case14(i);
		}
        /// <summary>
        /// Union case №15 (Represents type 'O')
        /// </summary>
		public sealed class Case15
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'O'
			/// </summary>
			public override bool IsO => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public O Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => o(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => o(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'O'
            /// </summary>
            /// <param name="item">Union value of the type O</param>
            public Case15(O item)
				: base() => Item = item;

			public static implicit operator O(Case15 c) => c.Item;
			public static implicit operator Case15(O i) => new Case15(i);
		}
        /// <summary>
        /// Union case №16 (Represents type 'P')
        /// </summary>
		public sealed class Case16
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'P'
			/// </summary>
			public override bool IsP => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public P Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => p(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => p(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'P'
            /// </summary>
            /// <param name="item">Union value of the type P</param>
            public Case16(P item)
				: base() => Item = item;

			public static implicit operator P(Case16 c) => c.Item;
			public static implicit operator Case16(P i) => new Case16(i);
		}
        /// <summary>
        /// Union case №17 (Represents type 'Q')
        /// </summary>
		public sealed class Case17
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'Q'
			/// </summary>
			public override bool IsQ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public Q Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => q(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => q(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'Q'
            /// </summary>
            /// <param name="item">Union value of the type Q</param>
            public Case17(Q item)
				: base() => Item = item;

			public static implicit operator Q(Case17 c) => c.Item;
			public static implicit operator Case17(Q i) => new Case17(i);
		}
        /// <summary>
        /// Union case №18 (Represents type 'R')
        /// </summary>
		public sealed class Case18
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'R'
			/// </summary>
			public override bool IsR => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public R Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => r(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => r(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'R'
            /// </summary>
            /// <param name="item">Union value of the type R</param>
            public Case18(R item)
				: base() => Item = item;

			public static implicit operator R(Case18 c) => c.Item;
			public static implicit operator Case18(R i) => new Case18(i);
		}
        /// <summary>
        /// Union case №19 (Represents type 'S')
        /// </summary>
		public sealed class Case19
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'S'
			/// </summary>
			public override bool IsS => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public S Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => s(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => s(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'S'
            /// </summary>
            /// <param name="item">Union value of the type S</param>
            public Case19(S item)
				: base() => Item = item;

			public static implicit operator S(Case19 c) => c.Item;
			public static implicit operator Case19(S i) => new Case19(i);
		}
        /// <summary>
        /// Union case №20 (Represents type 'T')
        /// </summary>
		public sealed class Case20
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'T'
			/// </summary>
			public override bool IsT => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public T Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => t(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => t(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'T'
            /// </summary>
            /// <param name="item">Union value of the type T</param>
            public Case20(T item)
				: base() => Item = item;

			public static implicit operator T(Case20 c) => c.Item;
			public static implicit operator Case20(T i) => new Case20(i);
		}
        /// <summary>
        /// Union case №21 (Represents type 'U')
        /// </summary>
		public sealed class Case21
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'U'
			/// </summary>
			public override bool IsU => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public U Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => u(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => u(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'U'
            /// </summary>
            /// <param name="item">Union value of the type U</param>
            public Case21(U item)
				: base() => Item = item;

			public static implicit operator U(Case21 c) => c.Item;
			public static implicit operator Case21(U i) => new Case21(i);
		}
        /// <summary>
        /// Union case №22 (Represents type 'V')
        /// </summary>
		public sealed class Case22
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'V'
			/// </summary>
			public override bool IsV => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public V Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => v(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => v(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'V'
            /// </summary>
            /// <param name="item">Union value of the type V</param>
            public Case22(V item)
				: base() => Item = item;

			public static implicit operator V(Case22 c) => c.Item;
			public static implicit operator Case22(V i) => new Case22(i);
		}
        /// <summary>
        /// Union case №23 (Represents type 'W')
        /// </summary>
		public sealed class Case23
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'W'
			/// </summary>
			public override bool IsW => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public W Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => w(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => w(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'W'
            /// </summary>
            /// <param name="item">Union value of the type W</param>
            public Case23(W item)
				: base() => Item = item;

			public static implicit operator W(Case23 c) => c.Item;
			public static implicit operator Case23(W i) => new Case23(i);
		}
        /// <summary>
        /// Union case №24 (Represents type 'X')
        /// </summary>
		public sealed class Case24
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'X'
			/// </summary>
			public override bool IsX => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public X Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => x(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => x(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'X'
            /// </summary>
            /// <param name="item">Union value of the type X</param>
            public Case24(X item)
				: base() => Item = item;

			public static implicit operator X(Case24 c) => c.Item;
			public static implicit operator Case24(X i) => new Case24(i);
		}
        /// <summary>
        /// Union case №25 (Represents type 'Y')
        /// </summary>
		public sealed class Case25
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'Y'
			/// </summary>
			public override bool IsY => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public Y Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => y(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => y(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'Y'
            /// </summary>
            /// <param name="item">Union value of the type Y</param>
            public Case25(Y item)
				: base() => Item = item;

			public static implicit operator Y(Case25 c) => c.Item;
			public static implicit operator Case25(Y i) => new Case25(i);
		}
        /// <summary>
        /// Union case №26 (Represents type 'Z')
        /// </summary>
		public sealed class Case26
			: Union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z>
		{
#if UNSAFE
			/// <summary>
			/// Returns, whether the current union instance is from the type 'Z'
			/// </summary>
			public override bool IsZ => true;
			/// <summary>
			/// The union's type-unsafe item
			/// </summary>
			public override object UnsafeItem => Item;
#endif
			/// <summary>
			/// The union's item
			/// </summary>
			public Z Item { get; }

			public override _ Match<_>(Func<A, _> a, Func<B, _> b, Func<C, _> c, Func<D, _> d, Func<E, _> e, Func<F, _> f, Func<G, _> g, Func<H, _> h, Func<I, _> i, Func<J, _> j, Func<K, _> k, Func<L, _> l, Func<M, _> m, Func<N, _> n, Func<O, _> o, Func<P, _> p, Func<Q, _> q, Func<R, _> r, Func<S, _> s, Func<T, _> t, Func<U, _> u, Func<V, _> v, Func<W, _> w, Func<X, _> x, Func<Y, _> y, Func<Z, _> z) => z(Item);
			
			public override void Match(Action<A> a, Action<B> b, Action<C> c, Action<D> d, Action<E> e, Action<F> f, Action<G> g, Action<H> h, Action<I> i, Action<J> j, Action<K> k, Action<L> l, Action<M> m, Action<N> n, Action<O> o, Action<P> p, Action<Q> q, Action<R> r, Action<S> s, Action<T> t, Action<U> u, Action<V> v, Action<W> w, Action<X> x, Action<Y> y, Action<Z> z) => z(Item);

			/// <summary>
            /// Creates a new union with '26' possible cases and sets it to a value of the type 'Z'
            /// </summary>
            /// <param name="item">Union value of the type Z</param>
            public Case26(Z item)
				: base() => Item = item;

			public static implicit operator Z(Case26 c) => c.Item;
			public static implicit operator Case26(Z i) => new Case26(i);
		}
	}
}
